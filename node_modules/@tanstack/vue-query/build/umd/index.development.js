(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue-demi')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue-demi'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VueQuery = {}, global.Vue));
})(this, (function (exports, vueDemi) { 'use strict';

  class Subscribable {
    constructor() {
      this.listeners = [];
      this.subscribe = this.subscribe.bind(this);
    }

    subscribe(listener) {
      this.listeners.push(listener);
      this.onSubscribe();
      return () => {
        this.listeners = this.listeners.filter(x => x !== listener);
        this.onUnsubscribe();
      };
    }

    hasListeners() {
      return this.listeners.length > 0;
    }

    onSubscribe() {// Do nothing
    }

    onUnsubscribe() {// Do nothing
    }

  }

  // TYPES
  // UTILS
  const isServer = typeof window === 'undefined' || 'Deno' in window;
  function noop() {
    return undefined;
  }
  function functionalUpdate(updater, input) {
    return typeof updater === 'function' ? updater(input) : updater;
  }
  function isValidTimeout(value) {
    return typeof value === 'number' && value >= 0 && value !== Infinity;
  }
  function difference(array1, array2) {
    return array1.filter(x => array2.indexOf(x) === -1);
  }
  function replaceAt(array, index, value) {
    const copy = array.slice(0);
    copy[index] = value;
    return copy;
  }
  function timeUntilStale(updatedAt, staleTime) {
    return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
  }
  function parseQueryArgs$1(arg1, arg2, arg3) {
    if (!isQueryKey$1(arg1)) {
      return arg1;
    }

    if (typeof arg2 === 'function') {
      return { ...arg3,
        queryKey: arg1,
        queryFn: arg2
      };
    }

    return { ...arg2,
      queryKey: arg1
    };
  }
  function parseMutationArgs$1(arg1, arg2, arg3) {
    if (isQueryKey$1(arg1)) {
      if (typeof arg2 === 'function') {
        return { ...arg3,
          mutationKey: arg1,
          mutationFn: arg2
        };
      }

      return { ...arg2,
        mutationKey: arg1
      };
    }

    if (typeof arg1 === 'function') {
      return { ...arg2,
        mutationFn: arg1
      };
    }

    return { ...arg1
    };
  }
  function parseFilterArgs$2(arg1, arg2, arg3) {
    return isQueryKey$1(arg1) ? [{ ...arg2,
      queryKey: arg1
    }, arg3] : [arg1 || {}, arg2];
  }
  function parseMutationFilterArgs(arg1, arg2, arg3) {
    return isQueryKey$1(arg1) ? [{ ...arg2,
      mutationKey: arg1
    }, arg3] : [arg1 || {}, arg2];
  }
  function matchQuery(filters, query) {
    const {
      type = 'all',
      exact,
      fetchStatus,
      predicate,
      queryKey,
      stale
    } = filters;

    if (isQueryKey$1(queryKey)) {
      if (exact) {
        if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
          return false;
        }
      } else if (!partialMatchKey(query.queryKey, queryKey)) {
        return false;
      }
    }

    if (type !== 'all') {
      const isActive = query.isActive();

      if (type === 'active' && !isActive) {
        return false;
      }

      if (type === 'inactive' && isActive) {
        return false;
      }
    }

    if (typeof stale === 'boolean' && query.isStale() !== stale) {
      return false;
    }

    if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {
      return false;
    }

    if (predicate && !predicate(query)) {
      return false;
    }

    return true;
  }
  function matchMutation(filters, mutation) {
    const {
      exact,
      fetching,
      predicate,
      mutationKey
    } = filters;

    if (isQueryKey$1(mutationKey)) {
      if (!mutation.options.mutationKey) {
        return false;
      }

      if (exact) {
        if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
          return false;
        }
      } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
        return false;
      }
    }

    if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {
      return false;
    }

    if (predicate && !predicate(mutation)) {
      return false;
    }

    return true;
  }
  function hashQueryKeyByOptions(queryKey, options) {
    const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
    return hashFn(queryKey);
  }
  /**
   * Default query keys hash function.
   * Hashes the value into a stable hash.
   */

  function hashQueryKey(queryKey) {
    return JSON.stringify(queryKey, (_, val) => isPlainObject$1(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val);
  }
  /**
   * Checks if key `b` partially matches with key `a`.
   */

  function partialMatchKey(a, b) {
    return partialDeepEqual(a, b);
  }
  /**
   * Checks if `b` partially matches with `a`.
   */

  function partialDeepEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (typeof a !== typeof b) {
      return false;
    }

    if (a && b && typeof a === 'object' && typeof b === 'object') {
      return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));
    }

    return false;
  }
  /**
   * This function returns `a` if `b` is deeply equal.
   * If not, it will replace any deeply equal children of `b` with those of `a`.
   * This can be used for structural sharing between JSON values for example.
   */

  function replaceEqualDeep(a, b) {
    if (a === b) {
      return a;
    }

    const array = isPlainArray(a) && isPlainArray(b);

    if (array || isPlainObject$1(a) && isPlainObject$1(b)) {
      const aSize = array ? a.length : Object.keys(a).length;
      const bItems = array ? b : Object.keys(b);
      const bSize = bItems.length;
      const copy = array ? [] : {};
      let equalItems = 0;

      for (let i = 0; i < bSize; i++) {
        const key = array ? i : bItems[i];
        copy[key] = replaceEqualDeep(a[key], b[key]);

        if (copy[key] === a[key]) {
          equalItems++;
        }
      }

      return aSize === bSize && equalItems === aSize ? a : copy;
    }

    return b;
  }
  /**
   * Shallow compare objects. Only works with objects that always have the same properties.
   */

  function shallowEqualObjects(a, b) {
    if (a && !b || b && !a) {
      return false;
    }

    for (const key in a) {
      if (a[key] !== b[key]) {
        return false;
      }
    }

    return true;
  }
  function isPlainArray(value) {
    return Array.isArray(value) && value.length === Object.keys(value).length;
  } // Copied from: https://github.com/jonschlinkert/is-plain-object

  function isPlainObject$1(o) {
    if (!hasObjectPrototype(o)) {
      return false;
    } // If has modified constructor


    const ctor = o.constructor;

    if (typeof ctor === 'undefined') {
      return true;
    } // If has modified prototype


    const prot = ctor.prototype;

    if (!hasObjectPrototype(prot)) {
      return false;
    } // If constructor does not have an Object-specific method


    if (!prot.hasOwnProperty('isPrototypeOf')) {
      return false;
    } // Most likely a plain Object


    return true;
  }

  function hasObjectPrototype(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
  }

  function isQueryKey$1(value) {
    return Array.isArray(value);
  }
  function isError(value) {
    return value instanceof Error;
  }
  function sleep(timeout) {
    return new Promise(resolve => {
      setTimeout(resolve, timeout);
    });
  }
  /**
   * Schedules a microtask.
   * This can be useful to schedule state updates after rendering.
   */

  function scheduleMicrotask(callback) {
    sleep(0).then(callback);
  }
  function getAbortController() {
    if (typeof AbortController === 'function') {
      return new AbortController();
    }

    return;
  }
  function replaceData(prevData, data, options) {
    // Use prev data if an isDataEqual function is defined and returns `true`
    if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {
      return prevData;
    } else if (typeof options.structuralSharing === 'function') {
      return options.structuralSharing(prevData, data);
    } else if (options.structuralSharing !== false) {
      // Structurally share data between prev and new data if needed
      return replaceEqualDeep(prevData, data);
    }

    return data;
  }

  class FocusManager extends Subscribable {
    constructor() {
      super();

      this.setup = onFocus => {
        // addEventListener does not exist in React Native, but window does
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!isServer && window.addEventListener) {
          const listener = () => onFocus(); // Listen to visibillitychange and focus


          window.addEventListener('visibilitychange', listener, false);
          window.addEventListener('focus', listener, false);
          return () => {
            // Be sure to unsubscribe if a new handler is set
            window.removeEventListener('visibilitychange', listener);
            window.removeEventListener('focus', listener);
          };
        }

        return;
      };
    }

    onSubscribe() {
      if (!this.cleanup) {
        this.setEventListener(this.setup);
      }
    }

    onUnsubscribe() {
      if (!this.hasListeners()) {
        var _this$cleanup;

        (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
        this.cleanup = undefined;
      }
    }

    setEventListener(setup) {
      var _this$cleanup2;

      this.setup = setup;
      (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
      this.cleanup = setup(focused => {
        if (typeof focused === 'boolean') {
          this.setFocused(focused);
        } else {
          this.onFocus();
        }
      });
    }

    setFocused(focused) {
      this.focused = focused;

      if (focused) {
        this.onFocus();
      }
    }

    onFocus() {
      this.listeners.forEach(listener => {
        listener();
      });
    }

    isFocused() {
      if (typeof this.focused === 'boolean') {
        return this.focused;
      } // document global can be unavailable in react native


      if (typeof document === 'undefined') {
        return true;
      }

      return [undefined, 'visible', 'prerender'].includes(document.visibilityState);
    }

  }
  const focusManager = new FocusManager();

  class OnlineManager extends Subscribable {
    constructor() {
      super();

      this.setup = onOnline => {
        // addEventListener does not exist in React Native, but window does
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!isServer && window.addEventListener) {
          const listener = () => onOnline(); // Listen to online


          window.addEventListener('online', listener, false);
          window.addEventListener('offline', listener, false);
          return () => {
            // Be sure to unsubscribe if a new handler is set
            window.removeEventListener('online', listener);
            window.removeEventListener('offline', listener);
          };
        }

        return;
      };
    }

    onSubscribe() {
      if (!this.cleanup) {
        this.setEventListener(this.setup);
      }
    }

    onUnsubscribe() {
      if (!this.hasListeners()) {
        var _this$cleanup;

        (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
        this.cleanup = undefined;
      }
    }

    setEventListener(setup) {
      var _this$cleanup2;

      this.setup = setup;
      (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
      this.cleanup = setup(online => {
        if (typeof online === 'boolean') {
          this.setOnline(online);
        } else {
          this.onOnline();
        }
      });
    }

    setOnline(online) {
      this.online = online;

      if (online) {
        this.onOnline();
      }
    }

    onOnline() {
      this.listeners.forEach(listener => {
        listener();
      });
    }

    isOnline() {
      if (typeof this.online === 'boolean') {
        return this.online;
      }

      if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {
        return true;
      }

      return navigator.onLine;
    }

  }
  const onlineManager = new OnlineManager();

  function defaultRetryDelay(failureCount) {
    return Math.min(1000 * 2 ** failureCount, 30000);
  }

  function canFetch(networkMode) {
    return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;
  }
  class CancelledError {
    constructor(options) {
      this.revert = options == null ? void 0 : options.revert;
      this.silent = options == null ? void 0 : options.silent;
    }

  }
  function isCancelledError(value) {
    return value instanceof CancelledError;
  }
  function createRetryer(config) {
    let isRetryCancelled = false;
    let failureCount = 0;
    let isResolved = false;
    let continueFn;
    let promiseResolve;
    let promiseReject;
    const promise = new Promise((outerResolve, outerReject) => {
      promiseResolve = outerResolve;
      promiseReject = outerReject;
    });

    const cancel = cancelOptions => {
      if (!isResolved) {
        reject(new CancelledError(cancelOptions));
        config.abort == null ? void 0 : config.abort();
      }
    };

    const cancelRetry = () => {
      isRetryCancelled = true;
    };

    const continueRetry = () => {
      isRetryCancelled = false;
    };

    const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();

    const resolve = value => {
      if (!isResolved) {
        isResolved = true;
        config.onSuccess == null ? void 0 : config.onSuccess(value);
        continueFn == null ? void 0 : continueFn();
        promiseResolve(value);
      }
    };

    const reject = value => {
      if (!isResolved) {
        isResolved = true;
        config.onError == null ? void 0 : config.onError(value);
        continueFn == null ? void 0 : continueFn();
        promiseReject(value);
      }
    };

    const pause = () => {
      return new Promise(continueResolve => {
        continueFn = value => {
          const canContinue = isResolved || !shouldPause();

          if (canContinue) {
            continueResolve(value);
          }

          return canContinue;
        };

        config.onPause == null ? void 0 : config.onPause();
      }).then(() => {
        continueFn = undefined;

        if (!isResolved) {
          config.onContinue == null ? void 0 : config.onContinue();
        }
      });
    }; // Create loop function


    const run = () => {
      // Do nothing if already resolved
      if (isResolved) {
        return;
      }

      let promiseOrValue; // Execute query

      try {
        promiseOrValue = config.fn();
      } catch (error) {
        promiseOrValue = Promise.reject(error);
      }

      Promise.resolve(promiseOrValue).then(resolve).catch(error => {
        var _config$retry, _config$retryDelay;

        // Stop if the fetch is already resolved
        if (isResolved) {
          return;
        } // Do we need to retry the request?


        const retry = (_config$retry = config.retry) != null ? _config$retry : 3;
        const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
        const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;
        const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);

        if (isRetryCancelled || !shouldRetry) {
          // We are done if the query does not need to be retried
          reject(error);
          return;
        }

        failureCount++; // Notify on fail

        config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay

        sleep(delay) // Pause if the document is not visible or when the device is offline
        .then(() => {
          if (shouldPause()) {
            return pause();
          }

          return;
        }).then(() => {
          if (isRetryCancelled) {
            reject(error);
          } else {
            run();
          }
        });
      });
    }; // Start loop


    if (canFetch(config.networkMode)) {
      run();
    } else {
      pause().then(run);
    }

    return {
      promise,
      cancel,
      continue: () => {
        const didContinue = continueFn == null ? void 0 : continueFn();
        return didContinue ? promise : Promise.resolve();
      },
      cancelRetry,
      continueRetry
    };
  }

  const defaultLogger = console;

  function createNotifyManager() {
    let queue = [];
    let transactions = 0;

    let notifyFn = callback => {
      callback();
    };

    let batchNotifyFn = callback => {
      callback();
    };

    const batch = callback => {
      let result;
      transactions++;

      try {
        result = callback();
      } finally {
        transactions--;

        if (!transactions) {
          flush();
        }
      }

      return result;
    };

    const schedule = callback => {
      if (transactions) {
        queue.push(callback);
      } else {
        scheduleMicrotask(() => {
          notifyFn(callback);
        });
      }
    };
    /**
     * All calls to the wrapped function will be batched.
     */


    const batchCalls = callback => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    };

    const flush = () => {
      const originalQueue = queue;
      queue = [];

      if (originalQueue.length) {
        scheduleMicrotask(() => {
          batchNotifyFn(() => {
            originalQueue.forEach(callback => {
              notifyFn(callback);
            });
          });
        });
      }
    };
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */


    const setNotifyFunction = fn => {
      notifyFn = fn;
    };
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */


    const setBatchNotifyFunction = fn => {
      batchNotifyFn = fn;
    };

    return {
      batch,
      batchCalls,
      schedule,
      setNotifyFunction,
      setBatchNotifyFunction
    };
  } // SINGLETON

  const notifyManager = createNotifyManager();

  class Removable {
    destroy() {
      this.clearGcTimeout();
    }

    scheduleGc() {
      this.clearGcTimeout();

      if (isValidTimeout(this.cacheTime)) {
        this.gcTimeout = setTimeout(() => {
          this.optionalRemove();
        }, this.cacheTime);
      }
    }

    updateCacheTime(newCacheTime) {
      // Default to 5 minutes (Infinity for server-side) if no cache time is set
      this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);
    }

    clearGcTimeout() {
      if (this.gcTimeout) {
        clearTimeout(this.gcTimeout);
        this.gcTimeout = undefined;
      }
    }

  }

  // CLASS
  class Query extends Removable {
    constructor(config) {
      super();
      this.abortSignalConsumed = false;
      this.defaultOptions = config.defaultOptions;
      this.setOptions(config.options);
      this.observers = [];
      this.cache = config.cache;
      this.logger = config.logger || defaultLogger;
      this.queryKey = config.queryKey;
      this.queryHash = config.queryHash;
      this.initialState = config.state || getDefaultState$1(this.options);
      this.state = this.initialState;
      this.scheduleGc();
    }

    get meta() {
      return this.options.meta;
    }

    setOptions(options) {
      this.options = { ...this.defaultOptions,
        ...options
      };
      this.updateCacheTime(this.options.cacheTime);
    }

    optionalRemove() {
      if (!this.observers.length && this.state.fetchStatus === 'idle') {
        this.cache.remove(this);
      }
    }

    setData(newData, options) {
      const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached

      this.dispatch({
        data,
        type: 'success',
        dataUpdatedAt: options == null ? void 0 : options.updatedAt,
        manual: options == null ? void 0 : options.manual
      });
      return data;
    }

    setState(state, setStateOptions) {
      this.dispatch({
        type: 'setState',
        state,
        setStateOptions
      });
    }

    cancel(options) {
      var _this$retryer;

      const promise = this.promise;
      (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);
      return promise ? promise.then(noop).catch(noop) : Promise.resolve();
    }

    destroy() {
      super.destroy();
      this.cancel({
        silent: true
      });
    }

    reset() {
      this.destroy();
      this.setState(this.initialState);
    }

    isActive() {
      return this.observers.some(observer => observer.options.enabled !== false);
    }

    isDisabled() {
      return this.getObserversCount() > 0 && !this.isActive();
    }

    isStale() {
      return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);
    }

    isStaleByTime(staleTime = 0) {
      return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
    }

    onFocus() {
      var _this$retryer2;

      const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());

      if (observer) {
        observer.refetch({
          cancelRefetch: false
        });
      } // Continue fetch if currently paused


      (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
    }

    onOnline() {
      var _this$retryer3;

      const observer = this.observers.find(x => x.shouldFetchOnReconnect());

      if (observer) {
        observer.refetch({
          cancelRefetch: false
        });
      } // Continue fetch if currently paused


      (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
    }

    addObserver(observer) {
      if (this.observers.indexOf(observer) === -1) {
        this.observers.push(observer); // Stop the query from being garbage collected

        this.clearGcTimeout();
        this.cache.notify({
          type: 'observerAdded',
          query: this,
          observer
        });
      }
    }

    removeObserver(observer) {
      if (this.observers.indexOf(observer) !== -1) {
        this.observers = this.observers.filter(x => x !== observer);

        if (!this.observers.length) {
          // If the transport layer does not support cancellation
          // we'll let the query continue so the result can be cached
          if (this.retryer) {
            if (this.abortSignalConsumed) {
              this.retryer.cancel({
                revert: true
              });
            } else {
              this.retryer.cancelRetry();
            }
          }

          this.scheduleGc();
        }

        this.cache.notify({
          type: 'observerRemoved',
          query: this,
          observer
        });
      }
    }

    getObserversCount() {
      return this.observers.length;
    }

    invalidate() {
      if (!this.state.isInvalidated) {
        this.dispatch({
          type: 'invalidate'
        });
      }
    }

    fetch(options, fetchOptions) {
      var _this$options$behavio, _context$fetchOptions;

      if (this.state.fetchStatus !== 'idle') {
        if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
          // Silently cancel current fetch if the user wants to cancel refetches
          this.cancel({
            silent: true
          });
        } else if (this.promise) {
          var _this$retryer4;

          // make sure that retries that were potentially cancelled due to unmounts can continue
          (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching

          return this.promise;
        }
      } // Update config if passed, otherwise the config from the last execution is used


      if (options) {
        this.setOptions(options);
      } // Use the options from the first observer with a query function if no function is found.
      // This can happen when the query is hydrated or created with setQueryData.


      if (!this.options.queryFn) {
        const observer = this.observers.find(x => x.options.queryFn);

        if (observer) {
          this.setOptions(observer.options);
        }
      }

      if (!Array.isArray(this.options.queryKey)) {
        {
          this.logger.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']");
        }
      }

      const abortController = getAbortController(); // Create query function context

      const queryFnContext = {
        queryKey: this.queryKey,
        pageParam: undefined,
        meta: this.meta
      }; // Adds an enumerable signal property to the object that
      // which sets abortSignalConsumed to true when the signal
      // is read.

      const addSignalProperty = object => {
        Object.defineProperty(object, 'signal', {
          enumerable: true,
          get: () => {
            if (abortController) {
              this.abortSignalConsumed = true;
              return abortController.signal;
            }

            return undefined;
          }
        });
      };

      addSignalProperty(queryFnContext); // Create fetch function

      const fetchFn = () => {
        if (!this.options.queryFn) {
          return Promise.reject('Missing queryFn');
        }

        this.abortSignalConsumed = false;
        return this.options.queryFn(queryFnContext);
      }; // Trigger behavior hook


      const context = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        state: this.state,
        fetchFn
      };
      addSignalProperty(context);
      (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted

      this.revertState = this.state; // Set to fetching state if not already in it

      if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
        var _context$fetchOptions2;

        this.dispatch({
          type: 'fetch',
          meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
        });
      }

      const onError = error => {
        // Optimistically update state if needed
        if (!(isCancelledError(error) && error.silent)) {
          this.dispatch({
            type: 'error',
            error: error
          });
        }

        if (!isCancelledError(error)) {
          var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;

          // Notify cache callback
          (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);
          (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);

          {
            this.logger.error(error);
          }
        }

        if (!this.isFetchingOptimistic) {
          // Schedule query gc after fetching
          this.scheduleGc();
        }

        this.isFetchingOptimistic = false;
      }; // Try to fetch the data


      this.retryer = createRetryer({
        fn: context.fetchFn,
        abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
        onSuccess: data => {
          var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;

          if (typeof data === 'undefined') {
            {
              this.logger.error("Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: " + this.queryHash);
            }

            onError(new Error(this.queryHash + " data is undefined"));
            return;
          }

          this.setData(data); // Notify cache callback

          (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);
          (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);

          if (!this.isFetchingOptimistic) {
            // Schedule query gc after fetching
            this.scheduleGc();
          }

          this.isFetchingOptimistic = false;
        },
        onError,
        onFail: (failureCount, error) => {
          this.dispatch({
            type: 'failed',
            failureCount,
            error
          });
        },
        onPause: () => {
          this.dispatch({
            type: 'pause'
          });
        },
        onContinue: () => {
          this.dispatch({
            type: 'continue'
          });
        },
        retry: context.options.retry,
        retryDelay: context.options.retryDelay,
        networkMode: context.options.networkMode
      });
      this.promise = this.retryer.promise;
      return this.promise;
    }

    dispatch(action) {
      const reducer = state => {
        var _action$meta, _action$dataUpdatedAt;

        switch (action.type) {
          case 'failed':
            return { ...state,
              fetchFailureCount: action.failureCount,
              fetchFailureReason: action.error
            };

          case 'pause':
            return { ...state,
              fetchStatus: 'paused'
            };

          case 'continue':
            return { ...state,
              fetchStatus: 'fetching'
            };

          case 'fetch':
            return { ...state,
              fetchFailureCount: 0,
              fetchFailureReason: null,
              fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
              fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',
              ...(!state.dataUpdatedAt && {
                error: null,
                status: 'loading'
              })
            };

          case 'success':
            return { ...state,
              data: action.data,
              dataUpdateCount: state.dataUpdateCount + 1,
              dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
              error: null,
              isInvalidated: false,
              status: 'success',
              ...(!action.manual && {
                fetchStatus: 'idle',
                fetchFailureCount: 0,
                fetchFailureReason: null
              })
            };

          case 'error':
            const error = action.error;

            if (isCancelledError(error) && error.revert && this.revertState) {
              return { ...this.revertState
              };
            }

            return { ...state,
              error: error,
              errorUpdateCount: state.errorUpdateCount + 1,
              errorUpdatedAt: Date.now(),
              fetchFailureCount: state.fetchFailureCount + 1,
              fetchFailureReason: error,
              fetchStatus: 'idle',
              status: 'error'
            };

          case 'invalidate':
            return { ...state,
              isInvalidated: true
            };

          case 'setState':
            return { ...state,
              ...action.state
            };
        }
      };

      this.state = reducer(this.state);
      notifyManager.batch(() => {
        this.observers.forEach(observer => {
          observer.onQueryUpdate(action);
        });
        this.cache.notify({
          query: this,
          type: 'updated',
          action
        });
      });
    }

  }

  function getDefaultState$1(options) {
    const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;
    const hasData = typeof data !== 'undefined';
    const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
    return {
      data,
      dataUpdateCount: 0,
      dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchMeta: null,
      isInvalidated: false,
      status: hasData ? 'success' : 'loading',
      fetchStatus: 'idle'
    };
  }

  // CLASS
  class QueryCache$1 extends Subscribable {
    constructor(config) {
      super();
      this.config = config || {};
      this.queries = [];
      this.queriesMap = {};
    }

    build(client, options, state) {
      var _options$queryHash;

      const queryKey = options.queryKey;
      const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);
      let query = this.get(queryHash);

      if (!query) {
        query = new Query({
          cache: this,
          logger: client.getLogger(),
          queryKey,
          queryHash,
          options: client.defaultQueryOptions(options),
          state,
          defaultOptions: client.getQueryDefaults(queryKey)
        });
        this.add(query);
      }

      return query;
    }

    add(query) {
      if (!this.queriesMap[query.queryHash]) {
        this.queriesMap[query.queryHash] = query;
        this.queries.push(query);
        this.notify({
          type: 'added',
          query
        });
      }
    }

    remove(query) {
      const queryInMap = this.queriesMap[query.queryHash];

      if (queryInMap) {
        query.destroy();
        this.queries = this.queries.filter(x => x !== query);

        if (queryInMap === query) {
          delete this.queriesMap[query.queryHash];
        }

        this.notify({
          type: 'removed',
          query
        });
      }
    }

    clear() {
      notifyManager.batch(() => {
        this.queries.forEach(query => {
          this.remove(query);
        });
      });
    }

    get(queryHash) {
      return this.queriesMap[queryHash];
    }

    getAll() {
      return this.queries;
    }

    find(arg1, arg2) {
      const [filters] = parseFilterArgs$2(arg1, arg2);

      if (typeof filters.exact === 'undefined') {
        filters.exact = true;
      }

      return this.queries.find(query => matchQuery(filters, query));
    }

    findAll(arg1, arg2) {
      const [filters] = parseFilterArgs$2(arg1, arg2);
      return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;
    }

    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach(listener => {
          listener(event);
        });
      });
    }

    onFocus() {
      notifyManager.batch(() => {
        this.queries.forEach(query => {
          query.onFocus();
        });
      });
    }

    onOnline() {
      notifyManager.batch(() => {
        this.queries.forEach(query => {
          query.onOnline();
        });
      });
    }

  }

  // CLASS
  class Mutation extends Removable {
    constructor(config) {
      super();
      this.defaultOptions = config.defaultOptions;
      this.mutationId = config.mutationId;
      this.mutationCache = config.mutationCache;
      this.logger = config.logger || defaultLogger;
      this.observers = [];
      this.state = config.state || getDefaultState();
      this.setOptions(config.options);
      this.scheduleGc();
    }

    setOptions(options) {
      this.options = { ...this.defaultOptions,
        ...options
      };
      this.updateCacheTime(this.options.cacheTime);
    }

    get meta() {
      return this.options.meta;
    }

    setState(state) {
      this.dispatch({
        type: 'setState',
        state
      });
    }

    addObserver(observer) {
      if (this.observers.indexOf(observer) === -1) {
        this.observers.push(observer); // Stop the mutation from being garbage collected

        this.clearGcTimeout();
        this.mutationCache.notify({
          type: 'observerAdded',
          mutation: this,
          observer
        });
      }
    }

    removeObserver(observer) {
      this.observers = this.observers.filter(x => x !== observer);
      this.scheduleGc();
      this.mutationCache.notify({
        type: 'observerRemoved',
        mutation: this,
        observer
      });
    }

    optionalRemove() {
      if (!this.observers.length) {
        if (this.state.status === 'loading') {
          this.scheduleGc();
        } else {
          this.mutationCache.remove(this);
        }
      }
    }

    continue() {
      var _this$retryer$continu, _this$retryer;

      return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();
    }

    async execute() {
      const executeMutation = () => {
        var _this$options$retry;

        this.retryer = createRetryer({
          fn: () => {
            if (!this.options.mutationFn) {
              return Promise.reject('No mutationFn found');
            }

            return this.options.mutationFn(this.state.variables);
          },
          onFail: (failureCount, error) => {
            this.dispatch({
              type: 'failed',
              failureCount,
              error
            });
          },
          onPause: () => {
            this.dispatch({
              type: 'pause'
            });
          },
          onContinue: () => {
            this.dispatch({
              type: 'continue'
            });
          },
          retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
          retryDelay: this.options.retryDelay,
          networkMode: this.options.networkMode
        });
        return this.retryer.promise;
      };

      const restored = this.state.status === 'loading';

      try {
        var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;

        if (!restored) {
          var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;

          this.dispatch({
            type: 'loading',
            variables: this.options.variables
          }); // Notify cache callback

          await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));
          const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));

          if (context !== this.state.context) {
            this.dispatch({
              type: 'loading',
              context,
              variables: this.state.variables
            });
          }
        }

        const data = await executeMutation(); // Notify cache callback

        await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));
        await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context)); // Notify cache callback

        await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));
        await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));
        this.dispatch({
          type: 'success',
          data
        });
        return data;
      } catch (error) {
        try {
          var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;

          // Notify cache callback
          await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));

          if ("development" !== 'production') {
            this.logger.error(error);
          }

          await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context)); // Notify cache callback

          await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, undefined, error, this.state.variables, this.state.context, this));
          await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));
          throw error;
        } finally {
          this.dispatch({
            type: 'error',
            error: error
          });
        }
      }
    }

    dispatch(action) {
      const reducer = state => {
        switch (action.type) {
          case 'failed':
            return { ...state,
              failureCount: action.failureCount,
              failureReason: action.error
            };

          case 'pause':
            return { ...state,
              isPaused: true
            };

          case 'continue':
            return { ...state,
              isPaused: false
            };

          case 'loading':
            return { ...state,
              context: action.context,
              data: undefined,
              failureCount: 0,
              failureReason: null,
              error: null,
              isPaused: !canFetch(this.options.networkMode),
              status: 'loading',
              variables: action.variables
            };

          case 'success':
            return { ...state,
              data: action.data,
              failureCount: 0,
              failureReason: null,
              error: null,
              status: 'success',
              isPaused: false
            };

          case 'error':
            return { ...state,
              data: undefined,
              error: action.error,
              failureCount: state.failureCount + 1,
              failureReason: action.error,
              isPaused: false,
              status: 'error'
            };

          case 'setState':
            return { ...state,
              ...action.state
            };
        }
      };

      this.state = reducer(this.state);
      notifyManager.batch(() => {
        this.observers.forEach(observer => {
          observer.onMutationUpdate(action);
        });
        this.mutationCache.notify({
          mutation: this,
          type: 'updated',
          action
        });
      });
    }

  }
  function getDefaultState() {
    return {
      context: undefined,
      data: undefined,
      error: null,
      failureCount: 0,
      failureReason: null,
      isPaused: false,
      status: 'idle',
      variables: undefined
    };
  }

  // CLASS
  class MutationCache$1 extends Subscribable {
    constructor(config) {
      super();
      this.config = config || {};
      this.mutations = [];
      this.mutationId = 0;
    }

    build(client, options, state) {
      const mutation = new Mutation({
        mutationCache: this,
        logger: client.getLogger(),
        mutationId: ++this.mutationId,
        options: client.defaultMutationOptions(options),
        state,
        defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined
      });
      this.add(mutation);
      return mutation;
    }

    add(mutation) {
      this.mutations.push(mutation);
      this.notify({
        type: 'added',
        mutation
      });
    }

    remove(mutation) {
      this.mutations = this.mutations.filter(x => x !== mutation);
      this.notify({
        type: 'removed',
        mutation
      });
    }

    clear() {
      notifyManager.batch(() => {
        this.mutations.forEach(mutation => {
          this.remove(mutation);
        });
      });
    }

    getAll() {
      return this.mutations;
    }

    find(filters) {
      if (typeof filters.exact === 'undefined') {
        filters.exact = true;
      }

      return this.mutations.find(mutation => matchMutation(filters, mutation));
    }

    findAll(filters) {
      return this.mutations.filter(mutation => matchMutation(filters, mutation));
    }

    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach(listener => {
          listener(event);
        });
      });
    }

    resumePausedMutations() {
      var _this$resuming;

      this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {
        const pausedMutations = this.mutations.filter(x => x.state.isPaused);
        return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));
      }).then(() => {
        this.resuming = undefined;
      });
      return this.resuming;
    }

  }

  function infiniteQueryBehavior() {
    return {
      onFetch: context => {
        context.fetchFn = () => {
          var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;

          const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
          const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
          const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
          const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';
          const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';
          const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
          const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
          let newPageParams = oldPageParams;
          let cancelled = false;

          const addSignalProperty = object => {
            Object.defineProperty(object, 'signal', {
              enumerable: true,
              get: () => {
                var _context$signal;

                if ((_context$signal = context.signal) != null && _context$signal.aborted) {
                  cancelled = true;
                } else {
                  var _context$signal2;

                  (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {
                    cancelled = true;
                  });
                }

                return context.signal;
              }
            });
          }; // Get query function


          const queryFn = context.options.queryFn || (() => Promise.reject('Missing queryFn'));

          const buildNewPages = (pages, param, page, previous) => {
            newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];
            return previous ? [page, ...pages] : [...pages, page];
          }; // Create function to fetch a page


          const fetchPage = (pages, manual, param, previous) => {
            if (cancelled) {
              return Promise.reject('Cancelled');
            }

            if (typeof param === 'undefined' && !manual && pages.length) {
              return Promise.resolve(pages);
            }

            const queryFnContext = {
              queryKey: context.queryKey,
              pageParam: param,
              meta: context.options.meta
            };
            addSignalProperty(queryFnContext);
            const queryFnResult = queryFn(queryFnContext);
            const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));
            return promise;
          };

          let promise; // Fetch first page?

          if (!oldPages.length) {
            promise = fetchPage([]);
          } // Fetch next page?
          else if (isFetchingNextPage) {
            const manual = typeof pageParam !== 'undefined';
            const param = manual ? pageParam : getNextPageParam(context.options, oldPages);
            promise = fetchPage(oldPages, manual, param);
          } // Fetch previous page?
          else if (isFetchingPreviousPage) {
            const manual = typeof pageParam !== 'undefined';
            const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);
            promise = fetchPage(oldPages, manual, param, true);
          } // Refetch pages
          else {
            newPageParams = [];
            const manual = typeof context.options.getNextPageParam === 'undefined';
            const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page

            promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages

            for (let i = 1; i < oldPages.length; i++) {
              promise = promise.then(pages => {
                const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;

                if (shouldFetchNextPage) {
                  const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);
                  return fetchPage(pages, manual, param);
                }

                return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));
              });
            }
          }

          const finalPromise = promise.then(pages => ({
            pages,
            pageParams: newPageParams
          }));
          return finalPromise;
        };
      }
    };
  }
  function getNextPageParam(options, pages) {
    return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
  }
  function getPreviousPageParam(options, pages) {
    return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
  }
  /**
   * Checks if there is a next page.
   * Returns `undefined` if it cannot be determined.
   */

  function hasNextPage(options, pages) {
    if (options.getNextPageParam && Array.isArray(pages)) {
      const nextPageParam = getNextPageParam(options, pages);
      return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;
    }

    return;
  }
  /**
   * Checks if there is a previous page.
   * Returns `undefined` if it cannot be determined.
   */

  function hasPreviousPage(options, pages) {
    if (options.getPreviousPageParam && Array.isArray(pages)) {
      const previousPageParam = getPreviousPageParam(options, pages);
      return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;
    }

    return;
  }

  // CLASS
  class QueryClient$1 {
    constructor(config = {}) {
      this.queryCache = config.queryCache || new QueryCache$1();
      this.mutationCache = config.mutationCache || new MutationCache$1();
      this.logger = config.logger || defaultLogger;
      this.defaultOptions = config.defaultOptions || {};
      this.queryDefaults = [];
      this.mutationDefaults = [];
      this.mountCount = 0;

      if (config.logger) {
        this.logger.error("Passing a custom logger has been deprecated and will be removed in the next major version.");
      }
    }

    mount() {
      this.mountCount++;
      if (this.mountCount !== 1) return;
      this.unsubscribeFocus = focusManager.subscribe(() => {
        if (focusManager.isFocused()) {
          this.resumePausedMutations();
          this.queryCache.onFocus();
        }
      });
      this.unsubscribeOnline = onlineManager.subscribe(() => {
        if (onlineManager.isOnline()) {
          this.resumePausedMutations();
          this.queryCache.onOnline();
        }
      });
    }

    unmount() {
      var _this$unsubscribeFocu, _this$unsubscribeOnli;

      this.mountCount--;
      if (this.mountCount !== 0) return;
      (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
      this.unsubscribeFocus = undefined;
      (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
      this.unsubscribeOnline = undefined;
    }

    isFetching(arg1, arg2) {
      const [filters] = parseFilterArgs$2(arg1, arg2);
      filters.fetchStatus = 'fetching';
      return this.queryCache.findAll(filters).length;
    }

    isMutating(filters) {
      return this.mutationCache.findAll({ ...filters,
        fetching: true
      }).length;
    }

    getQueryData(queryKey, filters) {
      var _this$queryCache$find;

      return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
    }

    ensureQueryData(arg1, arg2, arg3) {
      const parsedOptions = parseQueryArgs$1(arg1, arg2, arg3);
      const cachedData = this.getQueryData(parsedOptions.queryKey);
      return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);
    }

    getQueriesData(queryKeyOrFilters) {
      return this.getQueryCache().findAll(queryKeyOrFilters).map(({
        queryKey,
        state
      }) => {
        const data = state.data;
        return [queryKey, data];
      });
    }

    setQueryData(queryKey, updater, options) {
      const query = this.queryCache.find(queryKey);
      const prevData = query == null ? void 0 : query.state.data;
      const data = functionalUpdate(updater, prevData);

      if (typeof data === 'undefined') {
        return undefined;
      }

      const parsedOptions = parseQueryArgs$1(queryKey);
      const defaultedOptions = this.defaultQueryOptions(parsedOptions);
      return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,
        manual: true
      });
    }

    setQueriesData(queryKeyOrFilters, updater, options) {
      return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({
        queryKey
      }) => [queryKey, this.setQueryData(queryKey, updater, options)]));
    }

    getQueryState(queryKey, filters) {
      var _this$queryCache$find2;

      return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
    }

    removeQueries(arg1, arg2) {
      const [filters] = parseFilterArgs$2(arg1, arg2);
      const queryCache = this.queryCache;
      notifyManager.batch(() => {
        queryCache.findAll(filters).forEach(query => {
          queryCache.remove(query);
        });
      });
    }

    resetQueries(arg1, arg2, arg3) {
      const [filters, options] = parseFilterArgs$2(arg1, arg2, arg3);
      const queryCache = this.queryCache;
      const refetchFilters = {
        type: 'active',
        ...filters
      };
      return notifyManager.batch(() => {
        queryCache.findAll(filters).forEach(query => {
          query.reset();
        });
        return this.refetchQueries(refetchFilters, options);
      });
    }

    cancelQueries(arg1, arg2, arg3) {
      const [filters, cancelOptions = {}] = parseFilterArgs$2(arg1, arg2, arg3);

      if (typeof cancelOptions.revert === 'undefined') {
        cancelOptions.revert = true;
      }

      const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));
      return Promise.all(promises).then(noop).catch(noop);
    }

    invalidateQueries(arg1, arg2, arg3) {
      const [filters, options] = parseFilterArgs$2(arg1, arg2, arg3);
      return notifyManager.batch(() => {
        var _ref, _filters$refetchType;

        this.queryCache.findAll(filters).forEach(query => {
          query.invalidate();
        });

        if (filters.refetchType === 'none') {
          return Promise.resolve();
        }

        const refetchFilters = { ...filters,
          type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'
        };
        return this.refetchQueries(refetchFilters, options);
      });
    }

    refetchQueries(arg1, arg2, arg3) {
      const [filters, options] = parseFilterArgs$2(arg1, arg2, arg3);
      const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {
        var _options$cancelRefetc;

        return query.fetch(undefined, { ...options,
          cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,
          meta: {
            refetchPage: filters.refetchPage
          }
        });
      }));
      let promise = Promise.all(promises).then(noop);

      if (!(options != null && options.throwOnError)) {
        promise = promise.catch(noop);
      }

      return promise;
    }

    fetchQuery(arg1, arg2, arg3) {
      const parsedOptions = parseQueryArgs$1(arg1, arg2, arg3);
      const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652

      if (typeof defaultedOptions.retry === 'undefined') {
        defaultedOptions.retry = false;
      }

      const query = this.queryCache.build(this, defaultedOptions);
      return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
    }

    prefetchQuery(arg1, arg2, arg3) {
      return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);
    }

    fetchInfiniteQuery(arg1, arg2, arg3) {
      const parsedOptions = parseQueryArgs$1(arg1, arg2, arg3);
      parsedOptions.behavior = infiniteQueryBehavior();
      return this.fetchQuery(parsedOptions);
    }

    prefetchInfiniteQuery(arg1, arg2, arg3) {
      return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);
    }

    resumePausedMutations() {
      return this.mutationCache.resumePausedMutations();
    }

    getQueryCache() {
      return this.queryCache;
    }

    getMutationCache() {
      return this.mutationCache;
    }

    getLogger() {
      return this.logger;
    }

    getDefaultOptions() {
      return this.defaultOptions;
    }

    setDefaultOptions(options) {
      this.defaultOptions = options;
    }

    setQueryDefaults(queryKey, options) {
      const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));

      if (result) {
        result.defaultOptions = options;
      } else {
        this.queryDefaults.push({
          queryKey,
          defaultOptions: options
        });
      }
    }

    getQueryDefaults(queryKey) {
      if (!queryKey) {
        return undefined;
      } // Get the first matching defaults


      const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode

      {
        // Retrieve all matching defaults for the given key
        const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key

        if (matchingDefaults.length > 1) {
          this.logger.error("[QueryClient] Several query defaults match with key '" + JSON.stringify(queryKey) + "'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.");
        }
      }

      return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
    }

    setMutationDefaults(mutationKey, options) {
      const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));

      if (result) {
        result.defaultOptions = options;
      } else {
        this.mutationDefaults.push({
          mutationKey,
          defaultOptions: options
        });
      }
    }

    getMutationDefaults(mutationKey) {
      if (!mutationKey) {
        return undefined;
      } // Get the first matching defaults


      const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode

      {
        // Retrieve all matching defaults for the given key
        const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key

        if (matchingDefaults.length > 1) {
          this.logger.error("[QueryClient] Several mutation defaults match with key '" + JSON.stringify(mutationKey) + "'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.");
        }
      }

      return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
    }

    defaultQueryOptions(options) {
      if (options != null && options._defaulted) {
        return options;
      }

      const defaultedOptions = { ...this.defaultOptions.queries,
        ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),
        ...options,
        _defaulted: true
      };

      if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
        defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
      } // dependent default values


      if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {
        defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';
      }

      if (typeof defaultedOptions.useErrorBoundary === 'undefined') {
        defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
      }

      return defaultedOptions;
    }

    defaultMutationOptions(options) {
      if (options != null && options._defaulted) {
        return options;
      }

      return { ...this.defaultOptions.mutations,
        ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),
        ...options,
        _defaulted: true
      };
    }

    clear() {
      this.queryCache.clear();
      this.mutationCache.clear();
    }

  }

  class QueryObserver extends Subscribable {
    constructor(client, options) {
      super();
      this.client = client;
      this.options = options;
      this.trackedProps = new Set();
      this.selectError = null;
      this.bindMethods();
      this.setOptions(options);
    }

    bindMethods() {
      this.remove = this.remove.bind(this);
      this.refetch = this.refetch.bind(this);
    }

    onSubscribe() {
      if (this.listeners.length === 1) {
        this.currentQuery.addObserver(this);

        if (shouldFetchOnMount(this.currentQuery, this.options)) {
          this.executeFetch();
        }

        this.updateTimers();
      }
    }

    onUnsubscribe() {
      if (!this.listeners.length) {
        this.destroy();
      }
    }

    shouldFetchOnReconnect() {
      return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
    }

    shouldFetchOnWindowFocus() {
      return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
    }

    destroy() {
      this.listeners = [];
      this.clearStaleTimeout();
      this.clearRefetchInterval();
      this.currentQuery.removeObserver(this);
    }

    setOptions(options, notifyOptions) {
      const prevOptions = this.options;
      const prevQuery = this.currentQuery;
      this.options = this.client.defaultQueryOptions(options);

      if (typeof (options == null ? void 0 : options.isDataEqual) !== 'undefined') {
        this.client.getLogger().error("The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option");
      }

      if (!shallowEqualObjects(prevOptions, this.options)) {
        this.client.getQueryCache().notify({
          type: 'observerOptionsUpdated',
          query: this.currentQuery,
          observer: this
        });
      }

      if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {
        throw new Error('Expected enabled to be a boolean');
      } // Keep previous query key if the user does not supply one


      if (!this.options.queryKey) {
        this.options.queryKey = prevOptions.queryKey;
      }

      this.updateQuery();
      const mounted = this.hasListeners(); // Fetch if there are subscribers

      if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
        this.executeFetch();
      } // Update result


      this.updateResult(notifyOptions); // Update stale interval if needed

      if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
        this.updateStaleTimeout();
      }

      const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed

      if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
        this.updateRefetchInterval(nextRefetchInterval);
      }
    }

    getOptimisticResult(options) {
      const query = this.client.getQueryCache().build(this.client, options);
      return this.createResult(query, options);
    }

    getCurrentResult() {
      return this.currentResult;
    }

    trackResult(result) {
      const trackedResult = {};
      Object.keys(result).forEach(key => {
        Object.defineProperty(trackedResult, key, {
          configurable: false,
          enumerable: true,
          get: () => {
            this.trackedProps.add(key);
            return result[key];
          }
        });
      });
      return trackedResult;
    }

    getCurrentQuery() {
      return this.currentQuery;
    }

    remove() {
      this.client.getQueryCache().remove(this.currentQuery);
    }

    refetch({
      refetchPage,
      ...options
    } = {}) {
      return this.fetch({ ...options,
        meta: {
          refetchPage
        }
      });
    }

    fetchOptimistic(options) {
      const defaultedOptions = this.client.defaultQueryOptions(options);
      const query = this.client.getQueryCache().build(this.client, defaultedOptions);
      query.isFetchingOptimistic = true;
      return query.fetch().then(() => this.createResult(query, defaultedOptions));
    }

    fetch(fetchOptions) {
      var _fetchOptions$cancelR;

      return this.executeFetch({ ...fetchOptions,
        cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true
      }).then(() => {
        this.updateResult();
        return this.currentResult;
      });
    }

    executeFetch(fetchOptions) {
      // Make sure we reference the latest query as the current one might have been removed
      this.updateQuery(); // Fetch

      let promise = this.currentQuery.fetch(this.options, fetchOptions);

      if (!(fetchOptions != null && fetchOptions.throwOnError)) {
        promise = promise.catch(noop);
      }

      return promise;
    }

    updateStaleTimeout() {
      this.clearStaleTimeout();

      if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
        return;
      }

      const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.
      // To mitigate this issue we always add 1 ms to the timeout.

      const timeout = time + 1;
      this.staleTimeoutId = setTimeout(() => {
        if (!this.currentResult.isStale) {
          this.updateResult();
        }
      }, timeout);
    }

    computeRefetchInterval() {
      var _this$options$refetch;

      return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
    }

    updateRefetchInterval(nextInterval) {
      this.clearRefetchInterval();
      this.currentRefetchInterval = nextInterval;

      if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
        return;
      }

      this.refetchIntervalId = setInterval(() => {
        if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
          this.executeFetch();
        }
      }, this.currentRefetchInterval);
    }

    updateTimers() {
      this.updateStaleTimeout();
      this.updateRefetchInterval(this.computeRefetchInterval());
    }

    clearStaleTimeout() {
      if (this.staleTimeoutId) {
        clearTimeout(this.staleTimeoutId);
        this.staleTimeoutId = undefined;
      }
    }

    clearRefetchInterval() {
      if (this.refetchIntervalId) {
        clearInterval(this.refetchIntervalId);
        this.refetchIntervalId = undefined;
      }
    }

    createResult(query, options) {
      const prevQuery = this.currentQuery;
      const prevOptions = this.options;
      const prevResult = this.currentResult;
      const prevResultState = this.currentResultState;
      const prevResultOptions = this.currentResultOptions;
      const queryChange = query !== prevQuery;
      const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
      const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
      const {
        state
      } = query;
      let {
        dataUpdatedAt,
        error,
        errorUpdatedAt,
        fetchStatus,
        status
      } = state;
      let isPreviousData = false;
      let isPlaceholderData = false;
      let data; // Optimistically set result in fetching state if needed

      if (options._optimisticResults) {
        const mounted = this.hasListeners();
        const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
        const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);

        if (fetchOnMount || fetchOptionally) {
          fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';

          if (!dataUpdatedAt) {
            status = 'loading';
          }
        }

        if (options._optimisticResults === 'isRestoring') {
          fetchStatus = 'idle';
        }
      } // Keep previous data if needed


      if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {
        data = prevQueryResult.data;
        dataUpdatedAt = prevQueryResult.dataUpdatedAt;
        status = prevQueryResult.status;
        isPreviousData = true;
      } // Select data if needed
      else if (options.select && typeof state.data !== 'undefined') {
        // Memoize select result
        if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
          data = this.selectResult;
        } else {
          try {
            this.selectFn = options.select;
            data = options.select(state.data);
            data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
            this.selectResult = data;
            this.selectError = null;
          } catch (selectError) {
            {
              this.client.getLogger().error(selectError);
            }

            this.selectError = selectError;
          }
        }
      } // Use query data
      else {
        data = state.data;
      } // Show placeholder data if needed


      if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {
        let placeholderData; // Memoize placeholder data

        if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
          placeholderData = prevResult.data;
        } else {
          placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;

          if (options.select && typeof placeholderData !== 'undefined') {
            try {
              placeholderData = options.select(placeholderData);
              this.selectError = null;
            } catch (selectError) {
              {
                this.client.getLogger().error(selectError);
              }

              this.selectError = selectError;
            }
          }
        }

        if (typeof placeholderData !== 'undefined') {
          status = 'success';
          data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);
          isPlaceholderData = true;
        }
      }

      if (this.selectError) {
        error = this.selectError;
        data = this.selectResult;
        errorUpdatedAt = Date.now();
        status = 'error';
      }

      const isFetching = fetchStatus === 'fetching';
      const isLoading = status === 'loading';
      const isError = status === 'error';
      const result = {
        status,
        fetchStatus,
        isLoading,
        isSuccess: status === 'success',
        isError,
        isInitialLoading: isLoading && isFetching,
        data,
        dataUpdatedAt,
        error,
        errorUpdatedAt,
        failureCount: state.fetchFailureCount,
        failureReason: state.fetchFailureReason,
        errorUpdateCount: state.errorUpdateCount,
        isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
        isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
        isFetching,
        isRefetching: isFetching && !isLoading,
        isLoadingError: isError && state.dataUpdatedAt === 0,
        isPaused: fetchStatus === 'paused',
        isPlaceholderData,
        isPreviousData,
        isRefetchError: isError && state.dataUpdatedAt !== 0,
        isStale: isStale(query, options),
        refetch: this.refetch,
        remove: this.remove
      };
      return result;
    }

    updateResult(notifyOptions) {
      const prevResult = this.currentResult;
      const nextResult = this.createResult(this.currentQuery, this.options);
      this.currentResultState = this.currentQuery.state;
      this.currentResultOptions = this.options; // Only notify and update result if something has changed

      if (shallowEqualObjects(nextResult, prevResult)) {
        return;
      }

      this.currentResult = nextResult; // Determine which callbacks to trigger

      const defaultNotifyOptions = {
        cache: true
      };

      const shouldNotifyListeners = () => {
        if (!prevResult) {
          return true;
        }

        const {
          notifyOnChangeProps
        } = this.options;

        if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.trackedProps.size) {
          return true;
        }

        const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);

        if (this.options.useErrorBoundary) {
          includedProps.add('error');
        }

        return Object.keys(this.currentResult).some(key => {
          const typedKey = key;
          const changed = this.currentResult[typedKey] !== prevResult[typedKey];
          return changed && includedProps.has(typedKey);
        });
      };

      if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
        defaultNotifyOptions.listeners = true;
      }

      this.notify({ ...defaultNotifyOptions,
        ...notifyOptions
      });
    }

    updateQuery() {
      const query = this.client.getQueryCache().build(this.client, this.options);

      if (query === this.currentQuery) {
        return;
      }

      const prevQuery = this.currentQuery;
      this.currentQuery = query;
      this.currentQueryInitialState = query.state;
      this.previousQueryResult = this.currentResult;

      if (this.hasListeners()) {
        prevQuery == null ? void 0 : prevQuery.removeObserver(this);
        query.addObserver(this);
      }
    }

    onQueryUpdate(action) {
      const notifyOptions = {};

      if (action.type === 'success') {
        notifyOptions.onSuccess = !action.manual;
      } else if (action.type === 'error' && !isCancelledError(action.error)) {
        notifyOptions.onError = true;
      }

      this.updateResult(notifyOptions);

      if (this.hasListeners()) {
        this.updateTimers();
      }
    }

    notify(notifyOptions) {
      notifyManager.batch(() => {
        // First trigger the configuration callbacks
        if (notifyOptions.onSuccess) {
          var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;

          (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);
          (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);
        } else if (notifyOptions.onError) {
          var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;

          (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);
          (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);
        } // Then trigger the listeners


        if (notifyOptions.listeners) {
          this.listeners.forEach(listener => {
            listener(this.currentResult);
          });
        } // Then the cache listeners


        if (notifyOptions.cache) {
          this.client.getQueryCache().notify({
            query: this.currentQuery,
            type: 'observerResultsUpdated'
          });
        }
      });
    }

  }

  function shouldLoadOnMount(query, options) {
    return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);
  }

  function shouldFetchOnMount(query, options) {
    return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
  }

  function shouldFetchOn(query, options, field) {
    if (options.enabled !== false) {
      const value = typeof field === 'function' ? field(query) : field;
      return value === 'always' || value !== false && isStale(query, options);
    }

    return false;
  }

  function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
    return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);
  }

  function isStale(query, options) {
    return query.isStaleByTime(options.staleTime);
  }

  class QueriesObserver extends Subscribable {
    constructor(client, queries) {
      super();
      this.client = client;
      this.queries = [];
      this.result = [];
      this.observers = [];
      this.observersMap = {};

      if (queries) {
        this.setQueries(queries);
      }
    }

    onSubscribe() {
      if (this.listeners.length === 1) {
        this.observers.forEach(observer => {
          observer.subscribe(result => {
            this.onUpdate(observer, result);
          });
        });
      }
    }

    onUnsubscribe() {
      if (!this.listeners.length) {
        this.destroy();
      }
    }

    destroy() {
      this.listeners = [];
      this.observers.forEach(observer => {
        observer.destroy();
      });
    }

    setQueries(queries, notifyOptions) {
      this.queries = queries;
      notifyManager.batch(() => {
        const prevObservers = this.observers;
        const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes

        newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));
        const newObservers = newObserverMatches.map(match => match.observer);
        const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));
        const newResult = newObservers.map(observer => observer.getCurrentResult());
        const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);

        if (prevObservers.length === newObservers.length && !hasIndexChange) {
          return;
        }

        this.observers = newObservers;
        this.observersMap = newObserversMap;
        this.result = newResult;

        if (!this.hasListeners()) {
          return;
        }

        difference(prevObservers, newObservers).forEach(observer => {
          observer.destroy();
        });
        difference(newObservers, prevObservers).forEach(observer => {
          observer.subscribe(result => {
            this.onUpdate(observer, result);
          });
        });
        this.notify();
      });
    }

    getCurrentResult() {
      return this.result;
    }

    getQueries() {
      return this.observers.map(observer => observer.getCurrentQuery());
    }

    getObservers() {
      return this.observers;
    }

    getOptimisticResult(queries) {
      return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));
    }

    findMatchingObservers(queries) {
      const prevObservers = this.observers;
      const prevObserversMap = new Map(prevObservers.map(observer => [observer.options.queryHash, observer]));
      const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));
      const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {
        const match = prevObserversMap.get(defaultedOptions.queryHash);

        if (match != null) {
          return [{
            defaultedQueryOptions: defaultedOptions,
            observer: match
          }];
        }

        return [];
      });
      const matchedQueryHashes = new Set(matchingObservers.map(match => match.defaultedQueryOptions.queryHash));
      const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.has(defaultedOptions.queryHash));
      const matchingObserversSet = new Set(matchingObservers.map(match => match.observer));
      const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObserversSet.has(prevObserver));

      const getObserver = options => {
        const defaultedOptions = this.client.defaultQueryOptions(options);
        const currentObserver = this.observersMap[defaultedOptions.queryHash];
        return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);
      };

      const newOrReusedObservers = unmatchedQueries.map((options, index) => {
        if (options.keepPreviousData) {
          // return previous data from one of the observers that no longer match
          const previouslyUsedObserver = unmatchedObservers[index];

          if (previouslyUsedObserver !== undefined) {
            return {
              defaultedQueryOptions: options,
              observer: previouslyUsedObserver
            };
          }
        }

        return {
          defaultedQueryOptions: options,
          observer: getObserver(options)
        };
      });

      const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);

      return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);
    }

    onUpdate(observer, result) {
      const index = this.observers.indexOf(observer);

      if (index !== -1) {
        this.result = replaceAt(this.result, index, result);
        this.notify();
      }
    }

    notify() {
      notifyManager.batch(() => {
        this.listeners.forEach(listener => {
          listener(this.result);
        });
      });
    }

  }

  class InfiniteQueryObserver extends QueryObserver {
    // Type override
    // Type override
    // Type override
    // eslint-disable-next-line @typescript-eslint/no-useless-constructor
    constructor(client, options) {
      super(client, options);
    }

    bindMethods() {
      super.bindMethods();
      this.fetchNextPage = this.fetchNextPage.bind(this);
      this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
    }

    setOptions(options, notifyOptions) {
      super.setOptions({ ...options,
        behavior: infiniteQueryBehavior()
      }, notifyOptions);
    }

    getOptimisticResult(options) {
      options.behavior = infiniteQueryBehavior();
      return super.getOptimisticResult(options);
    }

    fetchNextPage({
      pageParam,
      ...options
    } = {}) {
      return this.fetch({ ...options,
        meta: {
          fetchMore: {
            direction: 'forward',
            pageParam
          }
        }
      });
    }

    fetchPreviousPage({
      pageParam,
      ...options
    } = {}) {
      return this.fetch({ ...options,
        meta: {
          fetchMore: {
            direction: 'backward',
            pageParam
          }
        }
      });
    }

    createResult(query, options) {
      var _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet, _state$data, _state$data2;

      const {
        state
      } = query;
      const result = super.createResult(query, options);
      const {
        isFetching,
        isRefetching
      } = result;
      const isFetchingNextPage = isFetching && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward';
      const isFetchingPreviousPage = isFetching && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward';
      return { ...result,
        fetchNextPage: this.fetchNextPage,
        fetchPreviousPage: this.fetchPreviousPage,
        hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),
        hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),
        isFetchingNextPage,
        isFetchingPreviousPage,
        isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage
      };
    }

  }

  // CLASS
  class MutationObserver extends Subscribable {
    constructor(client, options) {
      super();
      this.client = client;
      this.setOptions(options);
      this.bindMethods();
      this.updateResult();
    }

    bindMethods() {
      this.mutate = this.mutate.bind(this);
      this.reset = this.reset.bind(this);
    }

    setOptions(options) {
      var _this$currentMutation;

      const prevOptions = this.options;
      this.options = this.client.defaultMutationOptions(options);

      if (!shallowEqualObjects(prevOptions, this.options)) {
        this.client.getMutationCache().notify({
          type: 'observerOptionsUpdated',
          mutation: this.currentMutation,
          observer: this
        });
      }

      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);
    }

    onUnsubscribe() {
      if (!this.listeners.length) {
        var _this$currentMutation2;

        (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);
      }
    }

    onMutationUpdate(action) {
      this.updateResult(); // Determine which callbacks to trigger

      const notifyOptions = {
        listeners: true
      };

      if (action.type === 'success') {
        notifyOptions.onSuccess = true;
      } else if (action.type === 'error') {
        notifyOptions.onError = true;
      }

      this.notify(notifyOptions);
    }

    getCurrentResult() {
      return this.currentResult;
    }

    reset() {
      this.currentMutation = undefined;
      this.updateResult();
      this.notify({
        listeners: true
      });
    }

    mutate(variables, options) {
      this.mutateOptions = options;

      if (this.currentMutation) {
        this.currentMutation.removeObserver(this);
      }

      this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,
        variables: typeof variables !== 'undefined' ? variables : this.options.variables
      });
      this.currentMutation.addObserver(this);
      return this.currentMutation.execute();
    }

    updateResult() {
      const state = this.currentMutation ? this.currentMutation.state : getDefaultState();
      const result = { ...state,
        isLoading: state.status === 'loading',
        isSuccess: state.status === 'success',
        isError: state.status === 'error',
        isIdle: state.status === 'idle',
        mutate: this.mutate,
        reset: this.reset
      };
      this.currentResult = result;
    }

    notify(options) {
      notifyManager.batch(() => {
        // First trigger the mutate callbacks
        if (this.mutateOptions && this.hasListeners()) {
          if (options.onSuccess) {
            var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;

            (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
            (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
          } else if (options.onError) {
            var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;

            (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
            (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
          }
        } // Then trigger the listeners


        if (options.listeners) {
          this.listeners.forEach(listener => {
            listener(this.currentResult);
          });
        }
      });
    }

  }

  // TYPES
  // FUNCTIONS
  function dehydrateMutation(mutation) {
    return {
      mutationKey: mutation.options.mutationKey,
      state: mutation.state
    };
  } // Most config is not dehydrated but instead meant to configure again when
  // consuming the de/rehydrated data, typically with useQuery on the client.
  // Sometimes it might make sense to prefetch data on the server and include
  // in the html-payload, but not consume it on the initial render.


  function dehydrateQuery(query) {
    return {
      state: query.state,
      queryKey: query.queryKey,
      queryHash: query.queryHash
    };
  }

  function defaultShouldDehydrateMutation(mutation) {
    return mutation.state.isPaused;
  }
  function defaultShouldDehydrateQuery(query) {
    return query.state.status === 'success';
  }
  function dehydrate(client, options = {}) {
    const mutations = [];
    const queries = [];

    if (options.dehydrateMutations !== false) {
      const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;
      client.getMutationCache().getAll().forEach(mutation => {
        if (shouldDehydrateMutation(mutation)) {
          mutations.push(dehydrateMutation(mutation));
        }
      });
    }

    if (options.dehydrateQueries !== false) {
      const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;
      client.getQueryCache().getAll().forEach(query => {
        if (shouldDehydrateQuery(query)) {
          queries.push(dehydrateQuery(query));
        }
      });
    }

    return {
      mutations,
      queries
    };
  }
  function hydrate(client, dehydratedState, options) {
    if (typeof dehydratedState !== 'object' || dehydratedState === null) {
      return;
    }

    const mutationCache = client.getMutationCache();
    const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition

    const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition

    const queries = dehydratedState.queries || [];
    mutations.forEach(dehydratedMutation => {
      var _options$defaultOptio;

      mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),
        mutationKey: dehydratedMutation.mutationKey
      }, dehydratedMutation.state);
    });
    queries.forEach(dehydratedQuery => {
      var _options$defaultOptio2;

      const query = queryCache.get(dehydratedQuery.queryHash); // Reset fetch status to idle in the dehydrated state to avoid
      // query being stuck in fetching state upon hydration

      const dehydratedQueryState = { ...dehydratedQuery.state,
        fetchStatus: 'idle'
      }; // Do not hydrate if an existing query exists with newer data

      if (query) {
        if (query.state.dataUpdatedAt < dehydratedQueryState.dataUpdatedAt) {
          query.setState(dehydratedQueryState);
        }

        return;
      } // Restore query


      queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),
        queryKey: dehydratedQuery.queryKey,
        queryHash: dehydratedQuery.queryHash
      }, dehydratedQueryState);
    });
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  const VUE_QUERY_CLIENT = 'VUE_QUERY_CLIENT';
  function getClientKey(key) {
    const suffix = key ? ":" + key : '';
    return "" + VUE_QUERY_CLIENT + suffix;
  }
  function isQueryKey(value) {
    return Array.isArray(value);
  }
  function isMutationKey(value) {
    return Array.isArray(value);
  }
  function updateState(state, update) {
    Object.keys(state).forEach(key => {
      state[key] = update[key];
    });
  }
  function cloneDeep(value, customizer) {
    if (customizer) {
      const result = customizer(value);

      if (result !== undefined || vueDemi.isRef(value)) {
        return result;
      }
    }

    if (Array.isArray(value)) {
      return value.map(val => cloneDeep(val, customizer));
    }

    if (typeof value === 'object' && isPlainObject(value)) {
      const entries = Object.entries(value).map(([key, val]) => [key, cloneDeep(val, customizer)]);
      return Object.fromEntries(entries);
    }

    return value;
  }
  function cloneDeepUnref(obj) {
    return cloneDeep(obj, val => {
      if (vueDemi.isRef(val)) {
        return cloneDeepUnref(vueDemi.unref(val));
      }
    });
  }

  function isPlainObject(value) {
    if (Object.prototype.toString.call(value) !== '[object Object]') {
      return false;
    }

    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
  }

  function useQueryClient(id = '') {
    var _getCurrentInstance;

    const vm = (_getCurrentInstance = vueDemi.getCurrentInstance()) == null ? void 0 : _getCurrentInstance.proxy;

    if (!vm) {
      throw new Error('vue-query hooks can only be used inside setup() function.');
    }

    const key = getClientKey(id);
    const queryClient = vueDemi.inject(key);

    if (!queryClient) {
      throw new Error("No 'queryClient' found in Vue context, use 'VueQueryPlugin' to properly initialize the library.");
    }

    return queryClient;
  }

  class QueryCache extends QueryCache$1 {
    find(arg1, arg2) {
      const arg1Unreffed = cloneDeepUnref(arg1);
      const arg2Unreffed = cloneDeepUnref(arg2);
      return super.find(arg1Unreffed, arg2Unreffed);
    }

    findAll(arg1, arg2) {
      const arg1Unreffed = cloneDeepUnref(arg1);
      const arg2Unreffed = cloneDeepUnref(arg2);

      if (isQueryKey(arg1Unreffed)) {
        return super.findAll(arg1Unreffed, arg2Unreffed);
      }

      return super.findAll(arg1Unreffed);
    }

  }

  class MutationCache extends MutationCache$1 {
    find(filters) {
      return super.find(cloneDeepUnref(filters));
    }

    findAll(filters) {
      return super.findAll(cloneDeepUnref(filters));
    }

  }

  class QueryClient extends QueryClient$1 {
    constructor(config = {}) {
      const unreffedConfig = cloneDeepUnref(config);
      const vueQueryConfig = {
        logger: cloneDeepUnref(unreffedConfig.logger),
        defaultOptions: cloneDeepUnref(unreffedConfig.defaultOptions),
        queryCache: unreffedConfig.queryCache || new QueryCache(),
        mutationCache: unreffedConfig.mutationCache || new MutationCache()
      };
      super(vueQueryConfig);
      this.isRestoring = vueDemi.ref(false);
    }

    isFetching(arg1, arg2) {
      const arg1Unreffed = cloneDeepUnref(arg1);
      const arg2Unreffed = cloneDeepUnref(arg2);

      if (isQueryKey(arg1Unreffed)) {
        return super.isFetching(arg1Unreffed, arg2Unreffed);
      }

      return super.isFetching(arg1Unreffed);
    }

    isMutating(filters) {
      return super.isMutating(cloneDeepUnref(filters));
    }

    getQueryData(queryKey, filters) {
      return super.getQueryData(cloneDeepUnref(queryKey), cloneDeepUnref(filters));
    }

    getQueriesData(queryKeyOrFilters) {
      const unreffed = cloneDeepUnref(queryKeyOrFilters);

      if (isQueryKey(unreffed)) {
        return super.getQueriesData(unreffed);
      }

      return super.getQueriesData(unreffed);
    }

    setQueryData(queryKey, updater, options) {
      return super.setQueryData(cloneDeepUnref(queryKey), updater, cloneDeepUnref(options));
    }

    setQueriesData(queryKeyOrFilters, updater, options) {
      const arg1Unreffed = cloneDeepUnref(queryKeyOrFilters);
      const arg3Unreffed = cloneDeepUnref(options);

      if (isQueryKey(arg1Unreffed)) {
        return super.setQueriesData(arg1Unreffed, updater, arg3Unreffed);
      }

      return super.setQueriesData(arg1Unreffed, updater, arg3Unreffed);
    }

    getQueryState(queryKey, filters) {
      return super.getQueryState(cloneDeepUnref(queryKey), cloneDeepUnref(filters));
    }

    removeQueries(arg1, arg2) {
      const arg1Unreffed = cloneDeepUnref(arg1);

      if (isQueryKey(arg1Unreffed)) {
        return super.removeQueries(arg1Unreffed, cloneDeepUnref(arg2));
      }

      return super.removeQueries(arg1Unreffed);
    }

    resetQueries(arg1, arg2, arg3) {
      const arg1Unreffed = cloneDeepUnref(arg1);
      const arg2Unreffed = cloneDeepUnref(arg2);

      if (isQueryKey(arg1Unreffed)) {
        return super.resetQueries(arg1Unreffed, arg2Unreffed, cloneDeepUnref(arg3));
      }

      return super.resetQueries(arg1Unreffed, arg2Unreffed);
    }

    cancelQueries(arg1, arg2, arg3) {
      const arg1Unreffed = cloneDeepUnref(arg1);
      const arg2Unreffed = cloneDeepUnref(arg2);

      if (isQueryKey(arg1Unreffed)) {
        return super.cancelQueries(arg1Unreffed, arg2Unreffed, cloneDeepUnref(arg3));
      }

      return super.cancelQueries(arg1Unreffed, arg2Unreffed);
    }

    invalidateQueries(arg1, arg2, arg3) {
      const arg1Unreffed = cloneDeepUnref(arg1);
      const arg2Unreffed = cloneDeepUnref(arg2);

      if (isQueryKey(arg1Unreffed)) {
        return super.invalidateQueries(arg1Unreffed, arg2Unreffed, cloneDeepUnref(arg3));
      }

      return super.invalidateQueries(arg1Unreffed, arg2Unreffed);
    }

    refetchQueries(arg1, arg2, arg3) {
      const arg1Unreffed = cloneDeepUnref(arg1);
      const arg2Unreffed = cloneDeepUnref(arg2);

      if (isQueryKey(arg1Unreffed)) {
        return super.refetchQueries(arg1Unreffed, arg2Unreffed, cloneDeepUnref(arg3));
      }

      return super.refetchQueries(arg1Unreffed, arg2Unreffed);
    }

    fetchQuery(arg1, arg2, arg3) {
      const arg1Unreffed = cloneDeepUnref(arg1);
      const arg2Unreffed = cloneDeepUnref(arg2);

      if (isQueryKey(arg1Unreffed)) {
        return super.fetchQuery(arg1Unreffed, arg2Unreffed, cloneDeepUnref(arg3));
      }

      return super.fetchQuery(arg1Unreffed);
    }

    prefetchQuery(arg1, arg2, arg3) {
      return super.prefetchQuery(cloneDeepUnref(arg1), cloneDeepUnref(arg2), cloneDeepUnref(arg3));
    }

    fetchInfiniteQuery(arg1, arg2, arg3) {
      const arg1Unreffed = cloneDeepUnref(arg1);
      const arg2Unreffed = cloneDeepUnref(arg2);

      if (isQueryKey(arg1Unreffed)) {
        return super.fetchInfiniteQuery(arg1Unreffed, arg2Unreffed, cloneDeepUnref(arg3));
      }

      return super.fetchInfiniteQuery(arg1Unreffed);
    }

    prefetchInfiniteQuery(arg1, arg2, arg3) {
      return super.prefetchInfiniteQuery(cloneDeepUnref(arg1), cloneDeepUnref(arg2), cloneDeepUnref(arg3));
    }

    setDefaultOptions(options) {
      super.setDefaultOptions(cloneDeepUnref(options));
    }

    setQueryDefaults(queryKey, options) {
      super.setQueryDefaults(cloneDeepUnref(queryKey), cloneDeepUnref(options));
    }

    getQueryDefaults(queryKey) {
      return super.getQueryDefaults(cloneDeepUnref(queryKey));
    }

    setMutationDefaults(mutationKey, options) {
      super.setMutationDefaults(cloneDeepUnref(mutationKey), cloneDeepUnref(options));
    }

    getMutationDefaults(mutationKey) {
      return super.getMutationDefaults(cloneDeepUnref(mutationKey));
    }

  }

  function getDevtoolsGlobalHook() {
      return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
  }
  function getTarget() {
      // @ts-ignore
      return (typeof navigator !== 'undefined' && typeof window !== 'undefined')
          ? window
          : typeof global !== 'undefined'
              ? global
              : {};
  }
  const isProxyAvailable = typeof Proxy === 'function';

  const HOOK_SETUP = 'devtools-plugin:setup';
  const HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';

  let supported;
  let perf;
  function isPerformanceSupported() {
      var _a;
      if (supported !== undefined) {
          return supported;
      }
      if (typeof window !== 'undefined' && window.performance) {
          supported = true;
          perf = window.performance;
      }
      else if (typeof global !== 'undefined' && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
          supported = true;
          perf = global.perf_hooks.performance;
      }
      else {
          supported = false;
      }
      return supported;
  }
  function now() {
      return isPerformanceSupported() ? perf.now() : Date.now();
  }

  class ApiProxy {
      constructor(plugin, hook) {
          this.target = null;
          this.targetQueue = [];
          this.onQueue = [];
          this.plugin = plugin;
          this.hook = hook;
          const defaultSettings = {};
          if (plugin.settings) {
              for (const id in plugin.settings) {
                  const item = plugin.settings[id];
                  defaultSettings[id] = item.defaultValue;
              }
          }
          const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
          let currentSettings = Object.assign({}, defaultSettings);
          try {
              const raw = localStorage.getItem(localSettingsSaveId);
              const data = JSON.parse(raw);
              Object.assign(currentSettings, data);
          }
          catch (e) {
              // noop
          }
          this.fallbacks = {
              getSettings() {
                  return currentSettings;
              },
              setSettings(value) {
                  try {
                      localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
                  }
                  catch (e) {
                      // noop
                  }
                  currentSettings = value;
              },
              now() {
                  return now();
              },
          };
          if (hook) {
              hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
                  if (pluginId === this.plugin.id) {
                      this.fallbacks.setSettings(value);
                  }
              });
          }
          this.proxiedOn = new Proxy({}, {
              get: (_target, prop) => {
                  if (this.target) {
                      return this.target.on[prop];
                  }
                  else {
                      return (...args) => {
                          this.onQueue.push({
                              method: prop,
                              args,
                          });
                      };
                  }
              },
          });
          this.proxiedTarget = new Proxy({}, {
              get: (_target, prop) => {
                  if (this.target) {
                      return this.target[prop];
                  }
                  else if (prop === 'on') {
                      return this.proxiedOn;
                  }
                  else if (Object.keys(this.fallbacks).includes(prop)) {
                      return (...args) => {
                          this.targetQueue.push({
                              method: prop,
                              args,
                              resolve: () => { },
                          });
                          return this.fallbacks[prop](...args);
                      };
                  }
                  else {
                      return (...args) => {
                          return new Promise(resolve => {
                              this.targetQueue.push({
                                  method: prop,
                                  args,
                                  resolve,
                              });
                          });
                      };
                  }
              },
          });
      }
      async setRealTarget(target) {
          this.target = target;
          for (const item of this.onQueue) {
              this.target.on[item.method](...item.args);
          }
          for (const item of this.targetQueue) {
              item.resolve(await this.target[item.method](...item.args));
          }
      }
  }

  function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
      const descriptor = pluginDescriptor;
      const target = getTarget();
      const hook = getDevtoolsGlobalHook();
      const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
      if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
          hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
      }
      else {
          const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
          const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
          list.push({
              pluginDescriptor: descriptor,
              setupFn,
              proxy,
          });
          if (proxy)
              setupFn(proxy.proxiedTarget);
      }
  }

  /**
   * match-sorter-utils
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
  const characterMap = {
    À: 'A',
    Á: 'A',
    Â: 'A',
    Ã: 'A',
    Ä: 'A',
    Å: 'A',
    Ấ: 'A',
    Ắ: 'A',
    Ẳ: 'A',
    Ẵ: 'A',
    Ặ: 'A',
    Æ: 'AE',
    Ầ: 'A',
    Ằ: 'A',
    Ȃ: 'A',
    Ç: 'C',
    Ḉ: 'C',
    È: 'E',
    É: 'E',
    Ê: 'E',
    Ë: 'E',
    Ế: 'E',
    Ḗ: 'E',
    Ề: 'E',
    Ḕ: 'E',
    Ḝ: 'E',
    Ȇ: 'E',
    Ì: 'I',
    Í: 'I',
    Î: 'I',
    Ï: 'I',
    Ḯ: 'I',
    Ȋ: 'I',
    Ð: 'D',
    Ñ: 'N',
    Ò: 'O',
    Ó: 'O',
    Ô: 'O',
    Õ: 'O',
    Ö: 'O',
    Ø: 'O',
    Ố: 'O',
    Ṍ: 'O',
    Ṓ: 'O',
    Ȏ: 'O',
    Ù: 'U',
    Ú: 'U',
    Û: 'U',
    Ü: 'U',
    Ý: 'Y',
    à: 'a',
    á: 'a',
    â: 'a',
    ã: 'a',
    ä: 'a',
    å: 'a',
    ấ: 'a',
    ắ: 'a',
    ẳ: 'a',
    ẵ: 'a',
    ặ: 'a',
    æ: 'ae',
    ầ: 'a',
    ằ: 'a',
    ȃ: 'a',
    ç: 'c',
    ḉ: 'c',
    è: 'e',
    é: 'e',
    ê: 'e',
    ë: 'e',
    ế: 'e',
    ḗ: 'e',
    ề: 'e',
    ḕ: 'e',
    ḝ: 'e',
    ȇ: 'e',
    ì: 'i',
    í: 'i',
    î: 'i',
    ï: 'i',
    ḯ: 'i',
    ȋ: 'i',
    ð: 'd',
    ñ: 'n',
    ò: 'o',
    ó: 'o',
    ô: 'o',
    õ: 'o',
    ö: 'o',
    ø: 'o',
    ố: 'o',
    ṍ: 'o',
    ṓ: 'o',
    ȏ: 'o',
    ù: 'u',
    ú: 'u',
    û: 'u',
    ü: 'u',
    ý: 'y',
    ÿ: 'y',
    Ā: 'A',
    ā: 'a',
    Ă: 'A',
    ă: 'a',
    Ą: 'A',
    ą: 'a',
    Ć: 'C',
    ć: 'c',
    Ĉ: 'C',
    ĉ: 'c',
    Ċ: 'C',
    ċ: 'c',
    Č: 'C',
    č: 'c',
    C̆: 'C',
    c̆: 'c',
    Ď: 'D',
    ď: 'd',
    Đ: 'D',
    đ: 'd',
    Ē: 'E',
    ē: 'e',
    Ĕ: 'E',
    ĕ: 'e',
    Ė: 'E',
    ė: 'e',
    Ę: 'E',
    ę: 'e',
    Ě: 'E',
    ě: 'e',
    Ĝ: 'G',
    Ǵ: 'G',
    ĝ: 'g',
    ǵ: 'g',
    Ğ: 'G',
    ğ: 'g',
    Ġ: 'G',
    ġ: 'g',
    Ģ: 'G',
    ģ: 'g',
    Ĥ: 'H',
    ĥ: 'h',
    Ħ: 'H',
    ħ: 'h',
    Ḫ: 'H',
    ḫ: 'h',
    Ĩ: 'I',
    ĩ: 'i',
    Ī: 'I',
    ī: 'i',
    Ĭ: 'I',
    ĭ: 'i',
    Į: 'I',
    į: 'i',
    İ: 'I',
    ı: 'i',
    Ĳ: 'IJ',
    ĳ: 'ij',
    Ĵ: 'J',
    ĵ: 'j',
    Ķ: 'K',
    ķ: 'k',
    Ḱ: 'K',
    ḱ: 'k',
    K̆: 'K',
    k̆: 'k',
    Ĺ: 'L',
    ĺ: 'l',
    Ļ: 'L',
    ļ: 'l',
    Ľ: 'L',
    ľ: 'l',
    Ŀ: 'L',
    ŀ: 'l',
    Ł: 'l',
    ł: 'l',
    Ḿ: 'M',
    ḿ: 'm',
    M̆: 'M',
    m̆: 'm',
    Ń: 'N',
    ń: 'n',
    Ņ: 'N',
    ņ: 'n',
    Ň: 'N',
    ň: 'n',
    ŉ: 'n',
    N̆: 'N',
    n̆: 'n',
    Ō: 'O',
    ō: 'o',
    Ŏ: 'O',
    ŏ: 'o',
    Ő: 'O',
    ő: 'o',
    Œ: 'OE',
    œ: 'oe',
    P̆: 'P',
    p̆: 'p',
    Ŕ: 'R',
    ŕ: 'r',
    Ŗ: 'R',
    ŗ: 'r',
    Ř: 'R',
    ř: 'r',
    R̆: 'R',
    r̆: 'r',
    Ȓ: 'R',
    ȓ: 'r',
    Ś: 'S',
    ś: 's',
    Ŝ: 'S',
    ŝ: 's',
    Ş: 'S',
    Ș: 'S',
    ș: 's',
    ş: 's',
    Š: 'S',
    š: 's',
    Ţ: 'T',
    ţ: 't',
    ț: 't',
    Ț: 'T',
    Ť: 'T',
    ť: 't',
    Ŧ: 'T',
    ŧ: 't',
    T̆: 'T',
    t̆: 't',
    Ũ: 'U',
    ũ: 'u',
    Ū: 'U',
    ū: 'u',
    Ŭ: 'U',
    ŭ: 'u',
    Ů: 'U',
    ů: 'u',
    Ű: 'U',
    ű: 'u',
    Ų: 'U',
    ų: 'u',
    Ȗ: 'U',
    ȗ: 'u',
    V̆: 'V',
    v̆: 'v',
    Ŵ: 'W',
    ŵ: 'w',
    Ẃ: 'W',
    ẃ: 'w',
    X̆: 'X',
    x̆: 'x',
    Ŷ: 'Y',
    ŷ: 'y',
    Ÿ: 'Y',
    Y̆: 'Y',
    y̆: 'y',
    Ź: 'Z',
    ź: 'z',
    Ż: 'Z',
    ż: 'z',
    Ž: 'Z',
    ž: 'z',
    ſ: 's',
    ƒ: 'f',
    Ơ: 'O',
    ơ: 'o',
    Ư: 'U',
    ư: 'u',
    Ǎ: 'A',
    ǎ: 'a',
    Ǐ: 'I',
    ǐ: 'i',
    Ǒ: 'O',
    ǒ: 'o',
    Ǔ: 'U',
    ǔ: 'u',
    Ǖ: 'U',
    ǖ: 'u',
    Ǘ: 'U',
    ǘ: 'u',
    Ǚ: 'U',
    ǚ: 'u',
    Ǜ: 'U',
    ǜ: 'u',
    Ứ: 'U',
    ứ: 'u',
    Ṹ: 'U',
    ṹ: 'u',
    Ǻ: 'A',
    ǻ: 'a',
    Ǽ: 'AE',
    ǽ: 'ae',
    Ǿ: 'O',
    ǿ: 'o',
    Þ: 'TH',
    þ: 'th',
    Ṕ: 'P',
    ṕ: 'p',
    Ṥ: 'S',
    ṥ: 's',
    X́: 'X',
    x́: 'x',
    Ѓ: 'Г',
    ѓ: 'г',
    Ќ: 'К',
    ќ: 'к',
    A̋: 'A',
    a̋: 'a',
    E̋: 'E',
    e̋: 'e',
    I̋: 'I',
    i̋: 'i',
    Ǹ: 'N',
    ǹ: 'n',
    Ồ: 'O',
    ồ: 'o',
    Ṑ: 'O',
    ṑ: 'o',
    Ừ: 'U',
    ừ: 'u',
    Ẁ: 'W',
    ẁ: 'w',
    Ỳ: 'Y',
    ỳ: 'y',
    Ȁ: 'A',
    ȁ: 'a',
    Ȅ: 'E',
    ȅ: 'e',
    Ȉ: 'I',
    ȉ: 'i',
    Ȍ: 'O',
    ȍ: 'o',
    Ȑ: 'R',
    ȑ: 'r',
    Ȕ: 'U',
    ȕ: 'u',
    B̌: 'B',
    b̌: 'b',
    Č̣: 'C',
    č̣: 'c',
    Ê̌: 'E',
    ê̌: 'e',
    F̌: 'F',
    f̌: 'f',
    Ǧ: 'G',
    ǧ: 'g',
    Ȟ: 'H',
    ȟ: 'h',
    J̌: 'J',
    ǰ: 'j',
    Ǩ: 'K',
    ǩ: 'k',
    M̌: 'M',
    m̌: 'm',
    P̌: 'P',
    p̌: 'p',
    Q̌: 'Q',
    q̌: 'q',
    Ř̩: 'R',
    ř̩: 'r',
    Ṧ: 'S',
    ṧ: 's',
    V̌: 'V',
    v̌: 'v',
    W̌: 'W',
    w̌: 'w',
    X̌: 'X',
    x̌: 'x',
    Y̌: 'Y',
    y̌: 'y',
    A̧: 'A',
    a̧: 'a',
    B̧: 'B',
    b̧: 'b',
    Ḑ: 'D',
    ḑ: 'd',
    Ȩ: 'E',
    ȩ: 'e',
    Ɛ̧: 'E',
    ɛ̧: 'e',
    Ḩ: 'H',
    ḩ: 'h',
    I̧: 'I',
    i̧: 'i',
    Ɨ̧: 'I',
    ɨ̧: 'i',
    M̧: 'M',
    m̧: 'm',
    O̧: 'O',
    o̧: 'o',
    Q̧: 'Q',
    q̧: 'q',
    U̧: 'U',
    u̧: 'u',
    X̧: 'X',
    x̧: 'x',
    Z̧: 'Z',
    z̧: 'z'
  };
  const chars = Object.keys(characterMap).join('|');
  const allAccents = new RegExp(chars, 'g');
  function removeAccents(str) {
    return str.replace(allAccents, match => {
      return characterMap[match];
    });
  }

  /**
   * @name match-sorter
   * @license MIT license.
   * @copyright (c) 2099 Kent C. Dodds
   * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)
   */
  const rankings = {
    CASE_SENSITIVE_EQUAL: 7,
    EQUAL: 6,
    STARTS_WITH: 5,
    WORD_STARTS_WITH: 4,
    CONTAINS: 3,
    ACRONYM: 2,
    MATCHES: 1,
    NO_MATCH: 0
  };

  /**
   * Gets the highest ranking for value for the given item based on its values for the given keys
   * @param {*} item - the item to rank
   * @param {Array} keys - the keys to get values from the item for the ranking
   * @param {String} value - the value to rank against
   * @param {Object} options - options to control the ranking
   * @return {{rank: Number, accessorIndex: Number, accessorThreshold: Number}} - the highest ranking
   */
  function rankItem(item, value, options) {
    var _options$threshold;

    options = options || {};
    options.threshold = (_options$threshold = options.threshold) != null ? _options$threshold : rankings.MATCHES;

    if (!options.accessors) {
      // if keys is not specified, then we assume the item given is ready to be matched
      const rank = getMatchRanking(item, value, options);
      return {
        // ends up being duplicate of 'item' in matches but consistent
        rankedValue: item,
        rank,
        accessorIndex: -1,
        accessorThreshold: options.threshold,
        passed: rank >= options.threshold
      };
    }

    const valuesToRank = getAllValuesToRank(item, options.accessors);
    const rankingInfo = {
      rankedValue: item,
      rank: rankings.NO_MATCH,
      accessorIndex: -1,
      accessorThreshold: options.threshold,
      passed: false
    };

    for (let i = 0; i < valuesToRank.length; i++) {
      const rankValue = valuesToRank[i];
      let newRank = getMatchRanking(rankValue.itemValue, value, options);
      const {
        minRanking,
        maxRanking,
        threshold
      } = rankValue.attributes;

      if (newRank < minRanking && newRank >= rankings.MATCHES) {
        newRank = minRanking;
      } else if (newRank > maxRanking) {
        newRank = maxRanking;
      }

      newRank = Math.min(newRank, maxRanking);

      if (newRank > rankingInfo.rank) {
        rankingInfo.rank = newRank;
        rankingInfo.accessorIndex = i;
        rankingInfo.accessorThreshold = threshold;
        rankingInfo.rankedValue = rankValue.itemValue;
      }
    }

    return rankingInfo;
  }
  /**
   * Gives a rankings score based on how well the two strings match.
   * @param {String} testString - the string to test against
   * @param {String} stringToRank - the string to rank
   * @param {Object} options - options for the match (like keepDiacritics for comparison)
   * @returns {Number} the ranking for how well stringToRank matches testString
   */

  function getMatchRanking(testString, stringToRank, options) {
    testString = prepareValueForComparison(testString, options);
    stringToRank = prepareValueForComparison(stringToRank, options); // too long

    if (stringToRank.length > testString.length) {
      return rankings.NO_MATCH;
    } // case sensitive equals


    if (testString === stringToRank) {
      return rankings.CASE_SENSITIVE_EQUAL;
    } // Lower casing before further comparison


    testString = testString.toLowerCase();
    stringToRank = stringToRank.toLowerCase(); // case insensitive equals

    if (testString === stringToRank) {
      return rankings.EQUAL;
    } // starts with


    if (testString.startsWith(stringToRank)) {
      return rankings.STARTS_WITH;
    } // word starts with


    if (testString.includes(" " + stringToRank)) {
      return rankings.WORD_STARTS_WITH;
    } // contains


    if (testString.includes(stringToRank)) {
      return rankings.CONTAINS;
    } else if (stringToRank.length === 1) {
      // If the only character in the given stringToRank
      //   isn't even contained in the testString, then
      //   it's definitely not a match.
      return rankings.NO_MATCH;
    } // acronym


    if (getAcronym(testString).includes(stringToRank)) {
      return rankings.ACRONYM;
    } // will return a number between rankings.MATCHES and
    // rankings.MATCHES + 1 depending  on how close of a match it is.


    return getClosenessRanking(testString, stringToRank);
  }
  /**
   * Generates an acronym for a string.
   *
   * @param {String} string the string for which to produce the acronym
   * @returns {String} the acronym
   */


  function getAcronym(string) {
    let acronym = '';
    const wordsInString = string.split(' ');
    wordsInString.forEach(wordInString => {
      const splitByHyphenWords = wordInString.split('-');
      splitByHyphenWords.forEach(splitByHyphenWord => {
        acronym += splitByHyphenWord.substr(0, 1);
      });
    });
    return acronym;
  }
  /**
   * Returns a score based on how spread apart the
   * characters from the stringToRank are within the testString.
   * A number close to rankings.MATCHES represents a loose match. A number close
   * to rankings.MATCHES + 1 represents a tighter match.
   * @param {String} testString - the string to test against
   * @param {String} stringToRank - the string to rank
   * @returns {Number} the number between rankings.MATCHES and
   * rankings.MATCHES + 1 for how well stringToRank matches testString
   */


  function getClosenessRanking(testString, stringToRank) {
    let matchingInOrderCharCount = 0;
    let charNumber = 0;

    function findMatchingCharacter(matchChar, string, index) {
      for (let j = index, J = string.length; j < J; j++) {
        const stringChar = string[j];

        if (stringChar === matchChar) {
          matchingInOrderCharCount += 1;
          return j + 1;
        }
      }

      return -1;
    }

    function getRanking(spread) {
      const spreadPercentage = 1 / spread;
      const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;
      const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;
      return ranking;
    }

    const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);

    if (firstIndex < 0) {
      return rankings.NO_MATCH;
    }

    charNumber = firstIndex;

    for (let i = 1, I = stringToRank.length; i < I; i++) {
      const matchChar = stringToRank[i];
      charNumber = findMatchingCharacter(matchChar, testString, charNumber);
      const found = charNumber > -1;

      if (!found) {
        return rankings.NO_MATCH;
      }
    }

    const spread = charNumber - firstIndex;
    return getRanking(spread);
  }
  /**
   * Prepares value for comparison by stringifying it, removing diacritics (if specified)
   * @param {String} value - the value to clean
   * @param {Object} options - {keepDiacritics: whether to remove diacritics}
   * @return {String} the prepared value
   */

  function prepareValueForComparison(value, _ref) {
    let {
      keepDiacritics
    } = _ref;
    // value might not actually be a string at this point (we don't get to choose)
    // so part of preparing the value for comparison is ensure that it is a string
    value = "" + value; // toString

    if (!keepDiacritics) {
      value = removeAccents(value);
    }

    return value;
  }
  /**
   * Gets value for key in item at arbitrarily nested keypath
   * @param {Object} item - the item
   * @param {Object|Function} key - the potentially nested keypath or property callback
   * @return {Array} - an array containing the value(s) at the nested keypath
   */


  function getItemValues(item, accessor) {
    let accessorFn = accessor;

    if (typeof accessor === 'object') {
      accessorFn = accessor.accessor;
    }

    const value = accessorFn(item); // because `value` can also be undefined

    if (value == null) {
      return [];
    }

    if (Array.isArray(value)) {
      return value;
    }

    return [String(value)];
  }
  /**
   * Gets all the values for the given keys in the given item and returns an array of those values
   * @param item - the item from which the values will be retrieved
   * @param keys - the keys to use to retrieve the values
   * @return objects with {itemValue, attributes}
   */


  function getAllValuesToRank(item, accessors) {
    const allValues = [];

    for (let j = 0, J = accessors.length; j < J; j++) {
      const accessor = accessors[j];
      const attributes = getAccessorAttributes(accessor);
      const itemValues = getItemValues(item, accessor);

      for (let i = 0, I = itemValues.length; i < I; i++) {
        allValues.push({
          itemValue: itemValues[i],
          attributes
        });
      }
    }

    return allValues;
  }

  const defaultKeyAttributes = {
    maxRanking: Infinity,
    minRanking: -Infinity
  };
  /**
   * Gets all the attributes for the given accessor
   * @param accessor - the accessor from which the attributes will be retrieved
   * @return object containing the accessor's attributes
   */

  function getAccessorAttributes(accessor) {
    if (typeof accessor === 'function') {
      return defaultKeyAttributes;
    }

    return { ...defaultKeyAttributes,
      ...accessor
    };
  }

  /* istanbul ignore file */
  // eslint-disable-next-line no-shadow
  var QueryState;

  (function (QueryState) {
    QueryState[QueryState["Fetching"] = 0] = "Fetching";
    QueryState[QueryState["Fresh"] = 1] = "Fresh";
    QueryState[QueryState["Stale"] = 2] = "Stale";
    QueryState[QueryState["Inactive"] = 3] = "Inactive";
    QueryState[QueryState["Paused"] = 4] = "Paused";
  })(QueryState || (QueryState = {}));

  function getQueryState(query) {
    if (query.state.fetchStatus === 'fetching') {
      return QueryState.Fetching;
    }

    if (query.state.fetchStatus === 'paused') {
      return QueryState.Paused;
    }

    if (!query.getObserversCount()) {
      return QueryState.Inactive;
    }

    if (query.isStale()) {
      return QueryState.Stale;
    }

    return QueryState.Fresh;
  }
  function getQueryStateLabel(query) {
    const queryState = getQueryState(query);

    if (queryState === QueryState.Fetching) {
      return 'fetching';
    }

    if (queryState === QueryState.Paused) {
      return 'paused';
    }

    if (queryState === QueryState.Stale) {
      return 'stale';
    }

    if (queryState === QueryState.Inactive) {
      return 'inactive';
    }

    return 'fresh';
  }
  function getQueryStatusFg(query) {
    const queryState = getQueryState(query);

    if (queryState === QueryState.Stale) {
      return 0x000000;
    }

    return 0xffffff;
  }
  function getQueryStatusBg(query) {
    const queryState = getQueryState(query);

    if (queryState === QueryState.Fetching) {
      return 0x006bff;
    }

    if (queryState === QueryState.Paused) {
      return 0x8c49eb;
    }

    if (queryState === QueryState.Stale) {
      return 0xffb200;
    }

    if (queryState === QueryState.Inactive) {
      return 0x3f4e60;
    }

    return 0x008327;
  }

  const queryHashSort = (a, b) => a.queryHash.localeCompare(b.queryHash);

  const dateSort = (a, b) => a.state.dataUpdatedAt < b.state.dataUpdatedAt ? 1 : -1;

  const statusAndDateSort = (a, b) => {
    if (getQueryState(a) === getQueryState(b)) {
      return dateSort(a, b);
    }

    return getQueryState(a) > getQueryState(b) ? 1 : -1;
  };

  const sortFns = {
    'Status > Last Updated': statusAndDateSort,
    'Query Hash': queryHashSort,
    'Last Updated': dateSort
  };

  /* istanbul ignore file */
  const pluginId = 'vue-query';
  const pluginName = 'Vue Query';
  function setupDevtools(app, queryClient) {
    setupDevtoolsPlugin({
      id: pluginId,
      label: pluginName,
      packageName: 'vue-query',
      homepage: 'https://tanstack.com/query/v4',
      logo: 'https://vue-query.vercel.app/vue-query.svg',
      app,
      settings: {
        baseSort: {
          type: 'choice',
          component: 'button-group',
          label: 'Sort Cache Entries',
          options: [{
            label: 'ASC',
            value: 1
          }, {
            label: 'DESC',
            value: -1
          }],
          defaultValue: 1
        },
        sortFn: {
          type: 'choice',
          label: 'Sort Function',
          options: Object.keys(sortFns).map(key => ({
            label: key,
            value: key
          })),
          defaultValue: Object.keys(sortFns)[0]
        }
      }
    }, api => {
      const queryCache = queryClient.getQueryCache();
      api.addInspector({
        id: pluginId,
        label: pluginName,
        icon: 'api',
        nodeActions: [{
          icon: 'cloud_download',
          tooltip: 'Refetch',
          action: queryHash => {
            var _queryCache$get;

            (_queryCache$get = queryCache.get(queryHash)) == null ? void 0 : _queryCache$get.fetch();
          }
        }, {
          icon: 'alarm',
          tooltip: 'Invalidate',
          action: queryHash => {
            const query = queryCache.get(queryHash);
            queryClient.invalidateQueries(query.queryKey);
          }
        }, {
          icon: 'settings_backup_restore',
          tooltip: 'Reset',
          action: queryHash => {
            var _queryCache$get2;

            (_queryCache$get2 = queryCache.get(queryHash)) == null ? void 0 : _queryCache$get2.reset();
          }
        }, {
          icon: 'delete',
          tooltip: 'Remove',
          action: queryHash => {
            const query = queryCache.get(queryHash);
            queryCache.remove(query);
          }
        }]
      });
      api.addTimelineLayer({
        id: pluginId,
        label: pluginName,
        color: 0xffd94c
      });
      queryCache.subscribe(event => {
        api.sendInspectorTree(pluginId);
        api.sendInspectorState(pluginId);

        if ( // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        event && ['queryAdded', 'queryRemoved', 'queryUpdated'].includes(event.type)) {
          api.addTimelineEvent({
            layerId: pluginId,
            event: {
              title: event.type,
              subtitle: event.query.queryHash,
              time: api.now(),
              data: {
                queryHash: event.query.queryHash,
                ...event
              }
            }
          });
        }
      });
      api.on.getInspectorTree(payload => {
        if (payload.inspectorId === pluginId) {
          const queries = queryCache.getAll();
          const settings = api.getSettings();
          const filtered = payload.filter ? queries.filter(item => rankItem(item.queryHash, payload.filter).passed) : [...queries];
          const sorted = filtered.sort((a, b) => sortFns[settings.sortFn](a, b) * settings.baseSort);
          const nodes = sorted.map(query => {
            const stateLabel = getQueryStateLabel(query);
            return {
              id: query.queryHash,
              label: query.queryHash,
              tags: [{
                label: stateLabel + " [" + query.getObserversCount() + "]",
                textColor: getQueryStatusFg(query),
                backgroundColor: getQueryStatusBg(query)
              }]
            };
          });
          payload.rootNodes = nodes;
        }
      });
      api.on.getInspectorState(payload => {
        if (payload.inspectorId === pluginId) {
          const query = queryCache.get(payload.nodeId);

          if (!query) {
            return;
          }

          payload.state = {
            ' Query Details': [{
              key: 'Query key',
              value: query.queryHash
            }, {
              key: 'Query status',
              value: getQueryStateLabel(query)
            }, {
              key: 'Observers',
              value: query.getObserversCount()
            }, {
              key: 'Last Updated',
              value: new Date(query.state.dataUpdatedAt).toLocaleTimeString()
            }],
            'Data Explorer': [{
              key: 'Data',
              value: query.state.data
            }],
            'Query Explorer': [{
              key: 'Query',
              value: query
            }]
          };
        }
      });
    });
  }

  const VueQueryPlugin = {
    install: (app, options = {}) => {
      const clientKey = getClientKey(options.queryClientKey);
      let client;

      if ('queryClient' in options && options.queryClient) {
        client = options.queryClient;
      } else {
        if (options.contextSharing && typeof window !== 'undefined') {
          if (!window.__VUE_QUERY_CONTEXT__) {
            const clientConfig = 'queryClientConfig' in options ? options.queryClientConfig : undefined;
            client = new QueryClient(clientConfig);
            window.__VUE_QUERY_CONTEXT__ = client;
          } else {
            client = window.__VUE_QUERY_CONTEXT__;
          }
        } else {
          const clientConfig = 'queryClientConfig' in options ? options.queryClientConfig : undefined;
          client = new QueryClient(clientConfig);
        }
      }

      if (!isServer) {
        client.mount();
      }

      let persisterUnmount = () => {// noop
      };

      if (options.clientPersister) {
        client.isRestoring.value = true;
        const [unmount, promise] = options.clientPersister(client);
        persisterUnmount = unmount;
        promise.then(() => {
          client.isRestoring.value = false;
        });
      }

      if (options.contextSharing) {
        client.getLogger().error("The contextSharing option has been deprecated and will be removed in the next major version");
      }

      const cleanup = () => {
        client.unmount();
        persisterUnmount();
      };

      if (app.onUnmount) {
        app.onUnmount(cleanup);
      } else {
        const originalUnmount = app.unmount;

        app.unmount = function vueQueryUnmount() {
          cleanup();
          originalUnmount();
        };
      }
      /* istanbul ignore next */


      if (vueDemi.isVue2) {
        app.mixin({
          beforeCreate() {
            // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/master/src/apis/inject.ts#L30
            if (!this._provided) {
              const provideCache = {};
              Object.defineProperty(this, '_provided', {
                get: () => provideCache,
                set: v => Object.assign(provideCache, v)
              });
            }

            this._provided[clientKey] = client;

            {
              if (this === this.$root) {
                setupDevtools(this, client);
              }
            }
          }

        });
      } else {
        app.provide(clientKey, client);

        {
          setupDevtools(app, client);
        }
      }
    }
  };

  function useBaseQuery(Observer, arg1, arg2 = {}, arg3 = {}) {
    var _options$value$queryC;

    const options = vueDemi.computed(() => parseQueryArgs(arg1, arg2, arg3));
    const queryClient = (_options$value$queryC = options.value.queryClient) != null ? _options$value$queryC : useQueryClient(options.value.queryClientKey);
    const defaultedOptions = vueDemi.computed(() => {
      const defaulted = queryClient.defaultQueryOptions(options.value);
      defaulted._optimisticResults = queryClient.isRestoring.value ? 'isRestoring' : 'optimistic';
      return defaulted;
    });
    const observer = new Observer(queryClient, defaultedOptions.value);
    const state = vueDemi.reactive(observer.getCurrentResult());
    const unsubscribe = vueDemi.ref(() => {// noop
    });
    vueDemi.watch(queryClient.isRestoring, isRestoring => {
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (!isRestoring) {
        unsubscribe.value();
        unsubscribe.value = observer.subscribe(result => {
          updateState(state, result);
        });
      }
    }, {
      immediate: true
    });
    vueDemi.watch(defaultedOptions, () => {
      observer.setOptions(defaultedOptions.value);
      updateState(state, observer.getCurrentResult());
    }, {
      deep: true
    });
    vueDemi.onScopeDispose(() => {
      unsubscribe.value();
    });

    const suspense = () => {
      return new Promise(resolve => {
        let stopWatch = () => {//noop
        };

        const run = () => {
          if (defaultedOptions.value.enabled !== false) {
            const optimisticResult = observer.getOptimisticResult(defaultedOptions.value);

            if (optimisticResult.isStale) {
              stopWatch();
              resolve(observer.fetchOptimistic(defaultedOptions.value));
            } else {
              stopWatch();
              resolve(optimisticResult);
            }
          }
        };

        run();
        stopWatch = vueDemi.watch(defaultedOptions, run, {
          deep: true
        });
      });
    };

    return { ...vueDemi.toRefs(vueDemi.readonly(state)),
      suspense
    };
  }
  function parseQueryArgs(arg1, arg2 = {}, arg3 = {}) {
    const plainArg1 = vueDemi.unref(arg1);
    const plainArg2 = vueDemi.unref(arg2);
    const plainArg3 = vueDemi.unref(arg3);
    let options = plainArg1;

    if (!isQueryKey(plainArg1)) {
      options = plainArg1;
    } else if (typeof plainArg2 === 'function') {
      options = { ...plainArg3,
        queryKey: plainArg1,
        queryFn: plainArg2
      };
    } else {
      options = { ...plainArg2,
        queryKey: plainArg1
      };
    }

    return cloneDeepUnref(options);
  }

  function useQuery(arg1, arg2, arg3) {
    const result = useBaseQuery(QueryObserver, arg1, arg2, arg3);
    return { ...result,
      refetch: result.refetch.value,
      remove: result.remove.value
    };
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  function useQueries({
    queries,
    queryClient: queryClientInjected
  }) {
    var _unreffedQueries$valu, _unreffedQueries$valu2, _ref;

    const unreffedQueries = vueDemi.computed(() => cloneDeepUnref(queries));
    const queryClientKey = (_unreffedQueries$valu = unreffedQueries.value[0]) == null ? void 0 : _unreffedQueries$valu.queryClientKey;
    const optionsQueryClient = (_unreffedQueries$valu2 = unreffedQueries.value[0]) == null ? void 0 : _unreffedQueries$valu2.queryClient;
    const queryClient = (_ref = queryClientInjected != null ? queryClientInjected : optionsQueryClient) != null ? _ref : useQueryClient(queryClientKey);

    if ((queryClientKey || optionsQueryClient)) {
      queryClient.getLogger().error("Providing queryClient to individual queries in useQueries has been deprecated and will be removed in the next major version. You can still pass queryClient as an option directly to useQueries hook.");
    }

    const defaultedQueries = vueDemi.computed(() => unreffedQueries.value.map(options => {
      const defaulted = queryClient.defaultQueryOptions(options);
      defaulted._optimisticResults = queryClient.isRestoring.value ? 'isRestoring' : 'optimistic';
      return defaulted;
    }));
    const observer = new QueriesObserver(queryClient, defaultedQueries.value);
    const state = vueDemi.reactive(observer.getCurrentResult());
    const unsubscribe = vueDemi.ref(() => {// noop
    });
    vueDemi.watch(queryClient.isRestoring, isRestoring => {
      if (!isRestoring) {
        unsubscribe.value();
        unsubscribe.value = observer.subscribe(result => {
          state.splice(0, result.length, ...result);
        }); // Subscription would not fire for persisted results

        state.splice(0, state.length, ...observer.getOptimisticResult(defaultedQueries.value));
      }
    }, {
      immediate: true
    });
    vueDemi.watch(unreffedQueries, () => {
      observer.setQueries(defaultedQueries.value);
      state.splice(0, state.length, ...observer.getCurrentResult());
    }, {
      deep: true
    });
    vueDemi.onScopeDispose(() => {
      unsubscribe.value();
    });
    return vueDemi.readonly(state);
  }

  function useInfiniteQuery(arg1, arg2, arg3) {
    const result = useBaseQuery(InfiniteQueryObserver, arg1, arg2, arg3);
    return { ...result,
      fetchNextPage: result.fetchNextPage.value,
      fetchPreviousPage: result.fetchPreviousPage.value,
      refetch: result.refetch.value,
      remove: result.remove.value
    };
  }

  function useMutation(arg1, arg2, arg3) {
    var _options$value$queryC;

    const options = vueDemi.computed(() => {
      return parseMutationArgs(arg1, arg2, arg3);
    });
    const queryClient = (_options$value$queryC = options.value.queryClient) != null ? _options$value$queryC : useQueryClient(options.value.queryClientKey);
    const observer = new MutationObserver(queryClient, queryClient.defaultMutationOptions(options.value));
    const state = vueDemi.reactive(observer.getCurrentResult());
    const unsubscribe = observer.subscribe(result => {
      updateState(state, result);
    });

    const mutate = (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(() => {// This is intentional
      });
    };

    vueDemi.watch(options, () => {
      observer.setOptions(queryClient.defaultMutationOptions(options.value));
    }, {
      deep: true
    });
    vueDemi.onScopeDispose(() => {
      unsubscribe();
    });
    const resultRefs = vueDemi.toRefs(vueDemi.readonly(state));
    return { ...resultRefs,
      mutate,
      mutateAsync: state.mutate,
      reset: state.reset
    };
  }
  function parseMutationArgs(arg1, arg2, arg3) {
    const plainArg1 = vueDemi.unref(arg1);
    const plainArg2 = vueDemi.unref(arg2);
    let options = plainArg1;

    if (isMutationKey(plainArg1)) {
      if (typeof plainArg2 === 'function') {
        const plainArg3 = vueDemi.unref(arg3);
        options = { ...plainArg3,
          mutationKey: plainArg1,
          mutationFn: plainArg2
        };
      } else {
        options = { ...plainArg2,
          mutationKey: plainArg1
        };
      }
    }

    if (typeof plainArg1 === 'function') {
      options = { ...plainArg2,
        mutationFn: plainArg1
      };
    }

    return cloneDeepUnref(options);
  }

  function useIsFetching(arg1, arg2) {
    var _filters$value$queryC;

    const filters = vueDemi.computed(() => parseFilterArgs$1(arg1, arg2));
    const queryClient = (_filters$value$queryC = filters.value.queryClient) != null ? _filters$value$queryC : useQueryClient(filters.value.queryClientKey);
    const isFetching = vueDemi.ref(queryClient.isFetching(filters));
    const unsubscribe = queryClient.getQueryCache().subscribe(() => {
      isFetching.value = queryClient.isFetching(filters);
    });
    vueDemi.watch(filters, () => {
      isFetching.value = queryClient.isFetching(filters);
    }, {
      deep: true
    });
    vueDemi.onScopeDispose(() => {
      unsubscribe();
    });
    return isFetching;
  }
  function parseFilterArgs$1(arg1, arg2 = {}) {
    const plainArg1 = vueDemi.unref(arg1);
    const plainArg2 = vueDemi.unref(arg2);
    let options = plainArg1;

    if (isQueryKey(plainArg1)) {
      options = { ...plainArg2,
        queryKey: plainArg1
      };
    } else {
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      options = plainArg1 || {};
    }

    return cloneDeepUnref(options);
  }

  function useIsMutating(arg1, arg2) {
    var _filters$value$queryC;

    const filters = vueDemi.computed(() => parseFilterArgs(arg1, arg2));
    const queryClient = (_filters$value$queryC = filters.value.queryClient) != null ? _filters$value$queryC : useQueryClient(filters.value.queryClientKey);
    const isMutating = vueDemi.ref(queryClient.isMutating(filters));
    const unsubscribe = queryClient.getMutationCache().subscribe(() => {
      isMutating.value = queryClient.isMutating(filters);
    });
    vueDemi.watch(filters, () => {
      isMutating.value = queryClient.isMutating(filters);
    }, {
      deep: true
    });
    vueDemi.onScopeDispose(() => {
      unsubscribe();
    });
    return isMutating;
  }
  function parseFilterArgs(arg1, arg2 = {}) {
    const plainArg1 = vueDemi.unref(arg1);
    const plainArg2 = vueDemi.unref(arg2);
    let options = plainArg1;

    if (isQueryKey(plainArg1)) {
      options = { ...plainArg2,
        mutationKey: plainArg1
      };
    } else {
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      options = plainArg1 || {};
    }

    return cloneDeepUnref(options);
  }

  exports.CancelledError = CancelledError;
  exports.InfiniteQueryObserver = InfiniteQueryObserver;
  exports.MutationCache = MutationCache;
  exports.MutationObserver = MutationObserver;
  exports.QueriesObserver = QueriesObserver;
  exports.QueryCache = QueryCache;
  exports.QueryClient = QueryClient;
  exports.QueryObserver = QueryObserver;
  exports.VUE_QUERY_CLIENT = VUE_QUERY_CLIENT;
  exports.VueQueryPlugin = VueQueryPlugin;
  exports.defaultShouldDehydrateMutation = defaultShouldDehydrateMutation;
  exports.defaultShouldDehydrateQuery = defaultShouldDehydrateQuery;
  exports.dehydrate = dehydrate;
  exports.focusManager = focusManager;
  exports.hashQueryKey = hashQueryKey;
  exports.hydrate = hydrate;
  exports.isCancelledError = isCancelledError;
  exports.isError = isError;
  exports.isServer = isServer;
  exports.matchQuery = matchQuery;
  exports.notifyManager = notifyManager;
  exports.onlineManager = onlineManager;
  exports.parseFilterArgs = parseFilterArgs$2;
  exports.parseMutationArgs = parseMutationArgs$1;
  exports.parseMutationFilterArgs = parseMutationFilterArgs;
  exports.parseQueryArgs = parseQueryArgs$1;
  exports.replaceEqualDeep = replaceEqualDeep;
  exports.useInfiniteQuery = useInfiniteQuery;
  exports.useIsFetching = useIsFetching;
  exports.useIsMutating = useIsMutating;
  exports.useMutation = useMutation;
  exports.useQueries = useQueries;
  exports.useQuery = useQuery;
  exports.useQueryClient = useQueryClient;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.development.js.map
