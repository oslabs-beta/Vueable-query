import './index.css';
import { openBlock as d, createElementBlock as h, withModifiers as A, normalizeClass as P, createCommentVNode as b, toDisplayString as j, createElementVNode as C, isReactive as We, isRef as Ve, resolveComponent as de, createTextVNode as ye, Fragment as Ke, renderList as Ge, createBlock as he, defineComponent as Xe, normalizeStyle as qe } from "vue";
const ge = (e, t) => {
  const i = e.__vccOpts || e;
  for (const [o, s] of t)
    i[o] = s;
  return i;
}, Je = {
  name: "NodePrimitive",
  inheritAttrs: !1,
  emits: ["openParent", "show", "focus"],
  props: [
    // ref
    "root",
    "rootId",
    // options
    "modelValue",
    "name",
    "escapeQuotes",
    "save",
    "saveFocus",
    "focus",
    "delimiter",
    // helpers
    "parentOpen",
    "pointer",
    "type",
    "parentType",
    "size",
    "position",
    "expanded",
    // functions
    "escapeQuotesFn",
    "emitFn"
  ],
  data() {
    return {
      id: this.makeId(),
      hover: !1
    };
  },
  methods: {
    showEmit() {
      return this.emit("show", {
        pointer: this.pointer,
        pointerElement: this.$refs.focusElement,
        type: "primitive"
      }), !0;
    },
    focusEmit() {
      this.emit("focus", {
        pointer: this.pointer,
        focusElement: this.$refs.focusElement
      });
    },
    emit(e, ...t) {
      this.emitFn(this, e, ...t);
    },
    makeId() {
      const e = this.pointer !== "" ? `${this.delimiter}${this.pointer}` : "";
      return `_${this.rootId}${e}`;
    }
  },
  mounted() {
    this.showEmit();
  },
  computed: {
    parentIsArray() {
      return this.parentType === "array";
    },
    nameString() {
      return String(this.name);
    },
    showName() {
      return !this.parentIsArray && this.nameString || this.parentIsArray && this.parentOpen;
    },
    shouldComma() {
      return this.size && this.position && this.position !== this.size;
    },
    isFocused() {
      return String(this.pointer) === String(this.focus);
    }
  }
}, Ye = ["id"], $e = /* @__PURE__ */ C("span", { class: "vue-dd-colon" }, ":", -1), et = {
  key: 2,
  class: "vue-dd-null"
}, tt = {
  key: 3,
  class: "vue-dd-undefined"
}, nt = {
  key: 4,
  class: "vue-dd-number"
}, it = {
  key: 5,
  class: "vue-dd-bigint"
}, st = {
  key: 6,
  class: "vue-dd-string"
}, rt = {
  key: 8,
  class: "vue-dd-symbol"
}, ot = {
  key: 9,
  class: "vue-dd-unknown"
}, at = {
  key: 10,
  class: "vue-dd-comma"
};
function lt(e, t, i, o, s, n) {
  return d(), h("span", {
    id: s.id,
    class: "vue-dd-primitive",
    onClick: t[4] || (t[4] = A((l) => e.$emit("openParent"), ["prevent"]))
  }, [
    i.parentOpen && i.saveFocus ? (d(), h("span", {
      key: 0,
      ref: "focusElement",
      class: P(["vue-dd-focus vue-dd-icon-eye", {
        "vue-dd-focus-hover": s.hover,
        "vue-dd-focus-selected": n.isFocused
      }]),
      onClick: t[0] || (t[0] = A((...l) => n.focusEmit && n.focusEmit(...l), ["prevent"])),
      onMouseenter: t[1] || (t[1] = (l) => s.hover = !0),
      onMouseup: t[2] || (t[2] = (l) => s.hover = !1),
      onMouseleave: t[3] || (t[3] = (l) => s.hover = !1)
    }, null, 34)) : b("", !0),
    n.showName ? (d(), h("span", {
      key: 1,
      class: P({
        "vue-dd-key": !0,
        "vue-dd-key-of-array": n.parentIsArray
      })
    }, j(i.name), 3)) : b("", !0),
    $e,
    i.type === "null" ? (d(), h("span", et, "null")) : i.type === "undefined" ? (d(), h("span", tt, "undefined")) : i.type === "number" ? (d(), h("span", nt, j(i.modelValue), 1)) : i.type === "bigint" ? (d(), h("span", it, j(i.modelValue), 1)) : i.type === "string" ? (d(), h("span", st, '"' + j(i.escapeQuotesFn(i.modelValue)) + '"', 1)) : i.type === "boolean" ? (d(), h("span", {
      key: 7,
      class: P(["vue-dd-boolean", { "vue-dd-false": !i.modelValue }])
    }, j(i.modelValue), 3)) : i.type === "symbol" ? (d(), h("span", rt, j(i.modelValue.toString()), 1)) : (d(), h("span", ot, "[unknown_type]" + j(i.modelValue), 1)),
    n.shouldComma ? (d(), h("span", at, ",")) : b("", !0)
  ], 8, Ye);
}
const ze = /* @__PURE__ */ ge(Je, [["render", lt]]);
function ct(e) {
  let t = 0;
  for (let i = 0, o = e.length; i < o; i++) {
    let s = e.charCodeAt(i);
    t = (t << 5) - t + s, t |= 0;
  }
  return t;
}
function Ie(e) {
  return e && typeof e == "object" && !Array.isArray(e);
}
function ut(e) {
  return e !== null && typeof e == "object" && typeof e.then == "function" && typeof e.catch == "function";
}
function dt(e, t, i) {
  if (e !== "")
    return e;
  {
    const o = ht(i);
    return `${t}_${o}`;
  }
}
function ht(e) {
  const t = e.location.hash && typeof e.location.hash[1] < "u" && e.location.hash[1] === "/";
  let i = "";
  if (t)
    i = e.location.href.toString();
  else {
    const o = new URL(e.location.href);
    o.hash = "", i = o.toString();
  }
  return ct(i).toString(16).replace("-", "_");
}
function Ne(e, t = 0) {
  setTimeout(() => {
    window.requestAnimationFrame(() => window.requestAnimationFrame(e));
  }, t);
}
/*!
  Highlight.js v11.7.0 (git: 82688fad18)
  (c) 2006-2022 undefined and other contributors
  License: BSD-3-Clause
 */
var Oe = { exports: {} };
function Ee(e) {
  return e instanceof Map ? e.clear = e.delete = e.set = () => {
    throw Error("map is read-only");
  } : e instanceof Set && (e.add = e.clear = e.delete = () => {
    throw Error("set is read-only");
  }), Object.freeze(e), Object.getOwnPropertyNames(e).forEach((t) => {
    var i = e[t];
    typeof i != "object" || Object.isFrozen(i) || Ee(i);
  }), e;
}
Oe.exports = Ee, Oe.exports.default = Ee;
class Ae {
  constructor(t) {
    t.data === void 0 && (t.data = {}), this.data = t.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function He(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function U(e, ...t) {
  const i = /* @__PURE__ */ Object.create(null);
  for (const o in e)
    i[o] = e[o];
  return t.forEach((o) => {
    for (const s in o)
      i[s] = o[s];
  }), i;
}
const Te = (e) => !!e.scope || e.sublanguage && e.language;
class gt {
  constructor(t, i) {
    this.buffer = "", this.classPrefix = i.classPrefix, t.walk(this);
  }
  addText(t) {
    this.buffer += He(t);
  }
  openNode(t) {
    if (!Te(t))
      return;
    let i = "";
    i = t.sublanguage ? "language-" + t.language : ((o, { prefix: s }) => {
      if (o.includes(".")) {
        const n = o.split(".");
        return [`${s}${n.shift()}`, ...n.map((l, a) => `${l}${"_".repeat(a + 1)}`)].join(" ");
      }
      return `${s}${o}`;
    })(t.scope, { prefix: this.classPrefix }), this.span(i);
  }
  closeNode(t) {
    Te(t) && (this.buffer += "</span>");
  }
  value() {
    return this.buffer;
  }
  span(t) {
    this.buffer += `<span class="${t}">`;
  }
}
const Me = (e = {}) => {
  const t = { children: [] };
  return Object.assign(t, e), t;
};
class _e {
  constructor() {
    this.rootNode = Me(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  add(t) {
    this.top.children.push(t);
  }
  openNode(t) {
    const i = Me({ scope: t });
    this.add(i), this.stack.push(i);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); )
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  walk(t) {
    return this.constructor._walk(t, this.rootNode);
  }
  static _walk(t, i) {
    return typeof i == "string" ? t.addText(i) : i.children && (t.openNode(i), i.children.forEach((o) => this._walk(t, o)), t.closeNode(i)), t;
  }
  static _collapse(t) {
    typeof t != "string" && t.children && (t.children.every((i) => typeof i == "string") ? t.children = [t.children.join("")] : t.children.forEach((i) => {
      _e._collapse(i);
    }));
  }
}
class pt extends _e {
  constructor(t) {
    super(), this.options = t;
  }
  addKeyword(t, i) {
    t !== "" && (this.openNode(i), this.addText(t), this.closeNode());
  }
  addText(t) {
    t !== "" && this.add(t);
  }
  addSublanguage(t, i) {
    const o = t.root;
    o.sublanguage = !0, o.language = i, this.add(o);
  }
  toHTML() {
    return new gt(this, this.options).value();
  }
  finalize() {
    return !0;
  }
}
function oe(e) {
  return e ? typeof e == "string" ? e : e.source : null;
}
function De(e) {
  return Y("(?=", e, ")");
}
function ft(e) {
  return Y("(?:", e, ")*");
}
function mt(e) {
  return Y("(?:", e, ")?");
}
function Y(...e) {
  return e.map((t) => oe(t)).join("");
}
function xe(...e) {
  return "(" + (((i) => {
    const o = i[i.length - 1];
    return typeof o == "object" && o.constructor === Object ? (i.splice(i.length - 1, 1), o) : {};
  })(e).capture ? "" : "?:") + e.map((i) => oe(i)).join("|") + ")";
}
function Qe(e) {
  return RegExp(e.toString() + "|").exec("").length - 1;
}
const vt = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function ke(e, { joinWith: t }) {
  let i = 0;
  return e.map((o) => {
    i += 1;
    const s = i;
    let n = oe(o), l = "";
    for (; n.length > 0; ) {
      const a = vt.exec(n);
      if (!a) {
        l += n;
        break;
      }
      l += n.substring(0, a.index), n = n.substring(a.index + a[0].length), a[0][0] === "\\" && a[1] ? l += "\\" + (Number(a[1]) + s) : (l += a[0], a[0] === "(" && i++);
    }
    return l;
  }).map((o) => `(${o})`).join(t);
}
const Ce = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", re = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, yt = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [re]
}, bt = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [re]
}, pe = (e, t, i = {}) => {
  const o = U({
    scope: "comment",
    begin: e,
    end: t,
    contains: []
  }, i);
  o.contains.push({
    scope: "doctag",
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const s = xe("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
  return o.contains.push({ begin: Y(/[ ]+/, "(", s, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), o;
}, St = pe("//", "$"), wt = pe("/\\*", "\\*/"), Ot = pe("#", "$");
var ce = Object.freeze({
  __proto__: null,
  MATCH_NOTHING_RE: /\b\B/,
  IDENT_RE: "[a-zA-Z]\\w*",
  UNDERSCORE_IDENT_RE: "[a-zA-Z_]\\w*",
  NUMBER_RE: "\\b\\d+(\\.\\d+)?",
  C_NUMBER_RE: Ce,
  BINARY_NUMBER_RE: "\\b(0b[01]+)",
  RE_STARTERS_RE: "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
  SHEBANG: (e = {}) => {
    const t = /^#![ ]*\//;
    return e.binary && (e.begin = Y(t, /.*\b/, e.binary, /\b.*/)), U({
      scope: "meta",
      begin: t,
      end: /$/,
      relevance: 0,
      "on:begin": (i, o) => {
        i.index !== 0 && o.ignoreMatch();
      }
    }, e);
  },
  BACKSLASH_ESCAPE: re,
  APOS_STRING_MODE: yt,
  QUOTE_STRING_MODE: bt,
  PHRASAL_WORDS_MODE: {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  },
  COMMENT: pe,
  C_LINE_COMMENT_MODE: St,
  C_BLOCK_COMMENT_MODE: wt,
  HASH_COMMENT_MODE: Ot,
  NUMBER_MODE: { scope: "number", begin: "\\b\\d+(\\.\\d+)?", relevance: 0 },
  C_NUMBER_MODE: { scope: "number", begin: Ce, relevance: 0 },
  BINARY_NUMBER_MODE: {
    scope: "number",
    begin: "\\b(0b[01]+)",
    relevance: 0
  },
  REGEXP_MODE: {
    begin: /(?=\/[^/\n]*\/)/,
    contains: [{
      scope: "regexp",
      begin: /\//,
      end: /\/[gimuy]*/,
      illegal: /\n/,
      contains: [re, { begin: /\[/, end: /\]/, relevance: 0, contains: [re] }]
    }]
  },
  TITLE_MODE: { scope: "title", begin: "[a-zA-Z]\\w*", relevance: 0 },
  UNDERSCORE_TITLE_MODE: { scope: "title", begin: "[a-zA-Z_]\\w*", relevance: 0 },
  METHOD_GUARD: { begin: "\\.\\s*[a-zA-Z_]\\w*", relevance: 0 },
  END_SAME_AS_BEGIN: (e) => Object.assign(e, { "on:begin": (t, i) => {
    i.data._beginMatch = t[1];
  }, "on:end": (t, i) => {
    i.data._beginMatch !== t[1] && i.ignoreMatch();
  } })
});
function Et(e, t) {
  e.input[e.index - 1] === "." && t.ignoreMatch();
}
function kt(e, t) {
  e.className !== void 0 && (e.scope = e.className, delete e.className);
}
function Ft(e, t) {
  t && e.beginKeywords && (e.begin = "\\b(" + e.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", e.__beforeBegin = Et, e.keywords = e.keywords || e.beginKeywords, delete e.beginKeywords, e.relevance === void 0 && (e.relevance = 0));
}
function _t(e, t) {
  Array.isArray(e.illegal) && (e.illegal = xe(...e.illegal));
}
function xt(e, t) {
  if (e.match) {
    if (e.begin || e.end)
      throw Error("begin & end are not supported with match");
    e.begin = e.match, delete e.match;
  }
}
function It(e, t) {
  e.relevance === void 0 && (e.relevance = 1);
}
const Nt = (e, t) => {
  if (!e.beforeMatch)
    return;
  if (e.starts)
    throw Error("beforeMatch cannot be used with starts");
  const i = Object.assign({}, e);
  Object.keys(e).forEach((o) => {
    delete e[o];
  }), e.keywords = i.keywords, e.begin = Y(i.beforeMatch, De(i.begin)), e.starts = {
    relevance: 0,
    contains: [Object.assign(i, { endsParent: !0 })]
  }, e.relevance = 0, delete i.beforeMatch;
}, At = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"];
function Ue(e, t, i = "keyword") {
  const o = /* @__PURE__ */ Object.create(null);
  return typeof e == "string" ? s(i, e.split(" ")) : Array.isArray(e) ? s(i, e) : Object.keys(e).forEach((n) => {
    Object.assign(o, Ue(e[n], t, n));
  }), o;
  function s(n, l) {
    t && (l = l.map((a) => a.toLowerCase())), l.forEach((a) => {
      const r = a.split("|");
      o[r[0]] = [n, Tt(r[0], r[1])];
    });
  }
}
function Tt(e, t) {
  return t ? Number(t) : ((i) => At.includes(i.toLowerCase()))(e) ? 0 : 1;
}
const Le = {}, J = (e) => {
  console.error(e);
}, Re = (e, ...t) => {
  console.log("WARN: " + e, ...t);
}, te = (e, t) => {
  Le[`${e}/${t}`] || (console.log(`Deprecated as of ${e}. ${t}`), Le[`${e}/${t}`] = !0);
}, ue = Error();
function Pe(e, t, { key: i }) {
  let o = 0;
  const s = e[i], n = {}, l = {};
  for (let a = 1; a <= t.length; a++)
    l[a + o] = s[a], n[a + o] = !0, o += Qe(t[a - 1]);
  e[i] = l, e[i]._emit = n, e[i]._multi = !0;
}
function Mt(e) {
  ((t) => {
    t.scope && typeof t.scope == "object" && t.scope !== null && (t.beginScope = t.scope, delete t.scope);
  })(e), typeof e.beginScope == "string" && (e.beginScope = {
    _wrap: e.beginScope
  }), typeof e.endScope == "string" && (e.endScope = {
    _wrap: e.endScope
  }), ((t) => {
    if (Array.isArray(t.begin)) {
      if (t.skip || t.excludeBegin || t.returnBegin)
        throw J("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), ue;
      if (typeof t.beginScope != "object" || t.beginScope === null)
        throw J("beginScope must be object"), ue;
      Pe(t, t.begin, { key: "beginScope" }), t.begin = ke(t.begin, { joinWith: "" });
    }
  })(e), ((t) => {
    if (Array.isArray(t.end)) {
      if (t.skip || t.excludeEnd || t.returnEnd)
        throw J("skip, excludeEnd, returnEnd not compatible with endScope: {}"), ue;
      if (typeof t.endScope != "object" || t.endScope === null)
        throw J("endScope must be object"), ue;
      Pe(t, t.end, { key: "endScope" }), t.end = ke(t.end, { joinWith: "" });
    }
  })(e);
}
function Ct(e) {
  function t(s, n) {
    return RegExp(oe(s), "m" + (e.case_insensitive ? "i" : "") + (e.unicodeRegex ? "u" : "") + (n ? "g" : ""));
  }
  class i {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    addRule(n, l) {
      l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, n]), this.matchAt += Qe(n) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const n = this.regexes.map((l) => l[1]);
      this.matcherRe = t(ke(n, {
        joinWith: "|"
      }), !0), this.lastIndex = 0;
    }
    exec(n) {
      this.matcherRe.lastIndex = this.lastIndex;
      const l = this.matcherRe.exec(n);
      if (!l)
        return null;
      const a = l.findIndex((y, m) => m > 0 && y !== void 0), r = this.matchIndexes[a];
      return l.splice(0, a), Object.assign(l, r);
    }
  }
  class o {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    getMatcher(n) {
      if (this.multiRegexes[n])
        return this.multiRegexes[n];
      const l = new i();
      return this.rules.slice(n).forEach(([a, r]) => l.addRule(a, r)), l.compile(), this.multiRegexes[n] = l, l;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    addRule(n, l) {
      this.rules.push([n, l]), l.type === "begin" && this.count++;
    }
    exec(n) {
      const l = this.getMatcher(this.regexIndex);
      l.lastIndex = this.lastIndex;
      let a = l.exec(n);
      if (this.resumingScanAtSamePosition() && !(a && a.index === this.lastIndex)) {
        const r = this.getMatcher(0);
        r.lastIndex = this.lastIndex + 1, a = r.exec(n);
      }
      return a && (this.regexIndex += a.position + 1, this.regexIndex === this.count && this.considerAll()), a;
    }
  }
  if (e.compilerExtensions || (e.compilerExtensions = []), e.contains && e.contains.includes("self"))
    throw Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return e.classNameAliases = U(e.classNameAliases || {}), function s(n, l) {
    const a = n;
    if (n.isCompiled)
      return a;
    [kt, xt, Mt, Nt].forEach((y) => y(n, l)), e.compilerExtensions.forEach((y) => y(n, l)), n.__beforeBegin = null, [Ft, _t, It].forEach((y) => y(n, l)), n.isCompiled = !0;
    let r = null;
    return typeof n.keywords == "object" && n.keywords.$pattern && (n.keywords = Object.assign({}, n.keywords), r = n.keywords.$pattern, delete n.keywords.$pattern), r = r || /\w+/, n.keywords && (n.keywords = Ue(n.keywords, e.case_insensitive)), a.keywordPatternRe = t(r, !0), l && (n.begin || (n.begin = /\B|\b/), a.beginRe = t(a.begin), n.end || n.endsWithParent || (n.end = /\B|\b/), n.end && (a.endRe = t(a.end)), a.terminatorEnd = oe(a.end) || "", n.endsWithParent && l.terminatorEnd && (a.terminatorEnd += (n.end ? "|" : "") + l.terminatorEnd)), n.illegal && (a.illegalRe = t(n.illegal)), n.contains || (n.contains = []), n.contains = [].concat(...n.contains.map((y) => ((m) => (m.variants && !m.cachedVariants && (m.cachedVariants = m.variants.map((L) => U(m, {
      variants: null
    }, L))), m.cachedVariants ? m.cachedVariants : Ze(m) ? U(m, {
      starts: m.starts ? U(m.starts) : null
    }) : Object.isFrozen(m) ? U(m) : m))(y === "self" ? n : y))), n.contains.forEach((y) => {
      s(y, a);
    }), n.starts && s(n.starts, l), a.matcher = ((y) => {
      const m = new o();
      return y.contains.forEach((L) => m.addRule(L.begin, {
        rule: L,
        type: "begin"
      })), y.terminatorEnd && m.addRule(y.terminatorEnd, {
        type: "end"
      }), y.illegal && m.addRule(y.illegal, { type: "illegal" }), m;
    })(a), a;
  }(e);
}
function Ze(e) {
  return !!e && (e.endsWithParent || Ze(e.starts));
}
class Lt extends Error {
  constructor(t, i) {
    super(t), this.name = "HTMLInjectionError", this.html = i;
  }
}
const be = He, je = U, Be = Symbol("nomatch");
var Fe = ((e) => {
  const t = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), o = [];
  let s = !0;
  const n = "Could not find the language '{}', did you forget to load/include a language module?", l = {
    disableAutodetect: !0,
    name: "Plain text",
    contains: []
  };
  let a = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    __emitter: pt
  };
  function r(c) {
    return a.noHighlightRe.test(c);
  }
  function y(c, f, v) {
    let I = "", F = "";
    typeof f == "object" ? (I = c, v = f.ignoreIllegals, F = f.language) : (te("10.7.0", "highlight(lang, code, ...args) has been deprecated."), te("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), F = c, I = f), v === void 0 && (v = !0);
    const E = { code: I, language: F };
    K("before:highlight", E);
    const N = E.result ? E.result : m(E.language, E.code, v);
    return N.code = E.code, K("after:highlight", N), N;
  }
  function m(c, f, v, I) {
    const F = /* @__PURE__ */ Object.create(null);
    function E() {
      if (!g.keywords)
        return void x.addText(S);
      let u = 0;
      g.keywordPatternRe.lastIndex = 0;
      let p = g.keywordPatternRe.exec(S), O = "";
      for (; p; ) {
        O += S.substring(u, p.index);
        const k = z.case_insensitive ? p[0].toLowerCase() : p[0], T = (w = k, g.keywords[w]);
        if (T) {
          const [D, ve] = T;
          if (x.addText(O), O = "", F[k] = (F[k] || 0) + 1, F[k] <= 7 && (q += ve), D.startsWith("_"))
            O += p[0];
          else {
            const le = z.classNameAliases[D] || D;
            x.addKeyword(p[0], le);
          }
        } else
          O += p[0];
        u = g.keywordPatternRe.lastIndex, p = g.keywordPatternRe.exec(S);
      }
      var w;
      O += S.substring(u), x.addText(O);
    }
    function N() {
      g.subLanguage != null ? (() => {
        if (S === "")
          return;
        let u = null;
        if (typeof g.subLanguage == "string") {
          if (!t[g.subLanguage])
            return void x.addText(S);
          u = m(g.subLanguage, S, !0, ee[g.subLanguage]), ee[g.subLanguage] = u._top;
        } else
          u = L(S, g.subLanguage.length ? g.subLanguage : null);
        g.relevance > 0 && (q += u.relevance), x.addSublanguage(u._emitter, u.language);
      })() : E(), S = "";
    }
    function M(u, p) {
      let O = 1;
      const w = p.length - 1;
      for (; O <= w; ) {
        if (!u._emit[O]) {
          O++;
          continue;
        }
        const k = z.classNameAliases[u[O]] || u[O], T = p[O];
        k ? x.addKeyword(T, k) : (S = T, E(), S = ""), O++;
      }
    }
    function _(u, p) {
      return u.scope && typeof u.scope == "string" && x.openNode(z.classNameAliases[u.scope] || u.scope), u.beginScope && (u.beginScope._wrap ? (x.addKeyword(S, z.classNameAliases[u.beginScope._wrap] || u.beginScope._wrap), S = "") : u.beginScope._multi && (M(u.beginScope, p), S = "")), g = Object.create(u, { parent: {
        value: g
      } }), g;
    }
    function R(u, p, O) {
      let w = ((k, T) => {
        const D = k && k.exec(T);
        return D && D.index === 0;
      })(u.endRe, O);
      if (w) {
        if (u["on:end"]) {
          const k = new Ae(u);
          u["on:end"](p, k), k.isMatchIgnored && (w = !1);
        }
        if (w) {
          for (; u.endsParent && u.parent; )
            u = u.parent;
          return u;
        }
      }
      if (u.endsWithParent)
        return R(u.parent, p, O);
    }
    function ae(u) {
      return g.matcher.regexIndex === 0 ? (S += u[0], 1) : (me = !0, 0);
    }
    function fe(u) {
      const p = u[0], O = f.substring(u.index), w = R(g, u, O);
      if (!w)
        return Be;
      const k = g;
      g.endScope && g.endScope._wrap ? (N(), x.addKeyword(p, g.endScope._wrap)) : g.endScope && g.endScope._multi ? (N(), M(g.endScope, u)) : k.skip ? S += p : (k.returnEnd || k.excludeEnd || (S += p), N(), k.excludeEnd && (S = p));
      do
        g.scope && x.closeNode(), g.skip || g.subLanguage || (q += g.relevance), g = g.parent;
      while (g !== w.parent);
      return w.starts && _(w.starts, u), k.returnEnd ? 0 : p.length;
    }
    let $ = {};
    function ie(u, p) {
      const O = p && p[0];
      if (S += u, O == null)
        return N(), 0;
      if ($.type === "begin" && p.type === "end" && $.index === p.index && O === "") {
        if (S += f.slice(p.index, p.index + 1), !s) {
          const w = Error(`0 width match regex (${c})`);
          throw w.languageName = c, w.badRule = $.rule, w;
        }
        return 1;
      }
      if ($ = p, p.type === "begin")
        return ((w) => {
          const k = w[0], T = w.rule, D = new Ae(T), ve = [T.__beforeBegin, T["on:begin"]];
          for (const le of ve)
            if (le && (le(w, D), D.isMatchIgnored))
              return ae(k);
          return T.skip ? S += k : (T.excludeBegin && (S += k), N(), T.returnBegin || T.excludeBegin || (S = k)), _(T, w), T.returnBegin ? 0 : k.length;
        })(p);
      if (p.type === "illegal" && !v) {
        const w = Error('Illegal lexeme "' + O + '" for mode "' + (g.scope || "<unnamed>") + '"');
        throw w.mode = g, w;
      }
      if (p.type === "end") {
        const w = fe(p);
        if (w !== Be)
          return w;
      }
      if (p.type === "illegal" && O === "")
        return 1;
      if (se > 1e5 && se > 3 * p.index)
        throw Error("potential infinite loop, way more iterations than matches");
      return S += O, O.length;
    }
    const z = B(c);
    if (!z)
      throw J(n.replace("{}", c)), Error('Unknown language: "' + c + '"');
    const G = Ct(z);
    let X = "", g = I || G;
    const ee = {}, x = new a.__emitter(a);
    (() => {
      const u = [];
      for (let p = g; p !== z; p = p.parent)
        p.scope && u.unshift(p.scope);
      u.forEach((p) => x.openNode(p));
    })();
    let S = "", q = 0, H = 0, se = 0, me = !1;
    try {
      for (g.matcher.considerAll(); ; ) {
        se++, me ? me = !1 : g.matcher.considerAll(), g.matcher.lastIndex = H;
        const u = g.matcher.exec(f);
        if (!u)
          break;
        const p = ie(f.substring(H, u.index), u);
        H = u.index + p;
      }
      return ie(f.substring(H)), x.closeAllNodes(), x.finalize(), X = x.toHTML(), {
        language: c,
        value: X,
        relevance: q,
        illegal: !1,
        _emitter: x,
        _top: g
      };
    } catch (u) {
      if (u.message && u.message.includes("Illegal"))
        return {
          language: c,
          value: be(f),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: u.message,
            index: H,
            context: f.slice(H - 100, H + 100),
            mode: u.mode,
            resultSoFar: X
          },
          _emitter: x
        };
      if (s)
        return {
          language: c,
          value: be(f),
          illegal: !1,
          relevance: 0,
          errorRaised: u,
          _emitter: x,
          _top: g
        };
      throw u;
    }
  }
  function L(c, f) {
    f = f || a.languages || Object.keys(t);
    const v = ((_) => {
      const R = { value: be(_), illegal: !1, relevance: 0, _top: l, _emitter: new a.__emitter(a) };
      return R._emitter.addText(_), R;
    })(c), I = f.filter(B).filter(ne).map((_) => m(_, c, !1));
    I.unshift(v);
    const F = I.sort((_, R) => {
      if (_.relevance !== R.relevance)
        return R.relevance - _.relevance;
      if (_.language && R.language) {
        if (B(_.language).supersetOf === R.language)
          return 1;
        if (B(R.language).supersetOf === _.language)
          return -1;
      }
      return 0;
    }), [E, N] = F, M = E;
    return M.secondBest = N, M;
  }
  function V(c) {
    let f = null;
    const v = ((E) => {
      let N = E.className + " ";
      N += E.parentNode ? E.parentNode.className : "";
      const M = a.languageDetectRe.exec(N);
      if (M) {
        const _ = B(M[1]);
        return _ || (Re(n.replace("{}", M[1])), Re("Falling back to no-highlight mode for this block.", E)), _ ? M[1] : "no-highlight";
      }
      return N.split(/\s+/).find((_) => r(_) || B(_));
    })(c);
    if (r(v))
      return;
    if (K("before:highlightElement", {
      el: c,
      language: v
    }), c.children.length > 0 && (a.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(c)), a.throwUnescapedHTML))
      throw new Lt("One of your code blocks includes unescaped HTML.", c.innerHTML);
    f = c;
    const I = f.textContent, F = v ? y(I, { language: v, ignoreIllegals: !0 }) : L(I);
    c.innerHTML = F.value, ((E, N, M) => {
      const _ = N && i[N] || M;
      E.classList.add("hljs"), E.classList.add("language-" + _);
    })(c, v, F.language), c.result = {
      language: F.language,
      re: F.relevance,
      relevance: F.relevance
    }, F.secondBest && (c.secondBest = {
      language: F.secondBest.language,
      relevance: F.secondBest.relevance
    }), K("after:highlightElement", { el: c, result: F, text: I });
  }
  let Z = !1;
  function W() {
    document.readyState !== "loading" ? document.querySelectorAll(a.cssSelector).forEach(V) : Z = !0;
  }
  function B(c) {
    return c = (c || "").toLowerCase(), t[c] || t[i[c]];
  }
  function Q(c, { languageName: f }) {
    typeof c == "string" && (c = [c]), c.forEach((v) => {
      i[v.toLowerCase()] = f;
    });
  }
  function ne(c) {
    const f = B(c);
    return f && !f.disableAutodetect;
  }
  function K(c, f) {
    const v = c;
    o.forEach((I) => {
      I[v] && I[v](f);
    });
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", () => {
    Z && W();
  }, !1), Object.assign(e, {
    highlight: y,
    highlightAuto: L,
    highlightAll: W,
    highlightElement: V,
    highlightBlock: (c) => (te("10.7.0", "highlightBlock will be removed entirely in v12.0"), te("10.7.0", "Please use highlightElement now."), V(c)),
    configure: (c) => {
      a = je(a, c);
    },
    initHighlighting: () => {
      W(), te("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
    },
    initHighlightingOnLoad: () => {
      W(), te("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
    },
    registerLanguage: (c, f) => {
      let v = null;
      try {
        v = f(e);
      } catch (I) {
        if (J("Language definition for '{}' could not be registered.".replace("{}", c)), !s)
          throw I;
        J(I), v = l;
      }
      v.name || (v.name = c), t[c] = v, v.rawDefinition = f.bind(null, e), v.aliases && Q(v.aliases, {
        languageName: c
      });
    },
    unregisterLanguage: (c) => {
      delete t[c];
      for (const f of Object.keys(i))
        i[f] === c && delete i[f];
    },
    listLanguages: () => Object.keys(t),
    getLanguage: B,
    registerAliases: Q,
    autoDetection: ne,
    inherit: je,
    addPlugin: (c) => {
      ((f) => {
        f["before:highlightBlock"] && !f["before:highlightElement"] && (f["before:highlightElement"] = (v) => {
          f["before:highlightBlock"](Object.assign({ block: v.el }, v));
        }), f["after:highlightBlock"] && !f["after:highlightElement"] && (f["after:highlightElement"] = (v) => {
          f["after:highlightBlock"](Object.assign({ block: v.el }, v));
        });
      })(c), o.push(c);
    }
  }), e.debugMode = () => {
    s = !1;
  }, e.safeMode = () => {
    s = !0;
  }, e.versionString = "11.7.0", e.regex = {
    concat: Y,
    lookahead: De,
    either: xe,
    optional: mt,
    anyNumberOfTimes: ft
  };
  for (const c in ce)
    typeof ce[c] == "object" && Oe.exports(ce[c]);
  return Object.assign(e, ce), e;
})({});
/*! `javascript` grammar compiled for Highlight.js 11.7.0 */
var Rt = (() => {
  const e = "[A-Za-z$_][0-9A-Za-z$_]*", t = ["as", "in", "of", "if", "for", "while", "finally", "var", "new", "function", "do", "return", "void", "else", "break", "catch", "instanceof", "with", "throw", "case", "default", "try", "switch", "continue", "typeof", "delete", "let", "yield", "const", "class", "debugger", "async", "await", "static", "import", "from", "export", "extends"], i = ["true", "false", "null", "undefined", "NaN", "Infinity"], o = ["Object", "Function", "Boolean", "Symbol", "Math", "Date", "Number", "BigInt", "String", "RegExp", "Array", "Float32Array", "Float64Array", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Int32Array", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array", "Set", "Map", "WeakSet", "WeakMap", "ArrayBuffer", "SharedArrayBuffer", "Atomics", "DataView", "JSON", "Promise", "Generator", "GeneratorFunction", "AsyncFunction", "Reflect", "Proxy", "Intl", "WebAssembly"], s = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"], n = ["setInterval", "setTimeout", "clearInterval", "clearTimeout", "require", "exports", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape"], l = ["arguments", "this", "super", "console", "window", "document", "localStorage", "module", "global"], a = [].concat(n, o, s);
  return (r) => {
    const y = r.regex, m = e, L = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      isTrulyOpeningTag: (G, X) => {
        const g = G[0].length + G.index, ee = G.input[g];
        if (ee === "<" || ee === ",")
          return void X.ignoreMatch();
        let x;
        ee === ">" && (((q, { after: H }) => {
          const se = "</" + q[0].slice(1);
          return q.input.indexOf(se, H) !== -1;
        })(G, { after: g }) || X.ignoreMatch());
        const S = G.input.substring(g);
        ((x = S.match(/^\s*=/)) || (x = S.match(/^\s+extends\s+/)) && x.index === 0) && X.ignoreMatch();
      }
    }, V = {
      $pattern: e,
      keyword: t,
      literal: i,
      built_in: a,
      "variable.language": l
    }, Z = "\\.([0-9](_?[0-9])*)", W = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", B = {
      className: "number",
      variants: [{
        begin: `(\\b(${W})((${Z})|\\.)?|(${Z}))[eE][+-]?([0-9](_?[0-9])*)\\b`
      }, {
        begin: `\\b(${W})\\b((${Z})\\b|\\.)?|(${Z})\\b`
      }, {
        begin: "\\b(0|[1-9](_?[0-9])*)n\\b"
      }, {
        begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"
      }, {
        begin: "\\b0[bB][0-1](_?[0-1])*n?\\b"
      }, { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" }, {
        begin: "\\b0[0-7]+n?\\b"
      }],
      relevance: 0
    }, Q = {
      className: "subst",
      begin: "\\$\\{",
      end: "\\}",
      keywords: V,
      contains: []
    }, ne = { begin: "html`", end: "", starts: {
      end: "`",
      returnEnd: !1,
      contains: [r.BACKSLASH_ESCAPE, Q],
      subLanguage: "xml"
    } }, K = {
      begin: "css`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [r.BACKSLASH_ESCAPE, Q],
        subLanguage: "css"
      }
    }, c = {
      className: "string",
      begin: "`",
      end: "`",
      contains: [r.BACKSLASH_ESCAPE, Q]
    }, f = {
      className: "comment",
      variants: [r.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
        relevance: 0,
        contains: [{
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [{
            className: "doctag",
            begin: "@[A-Za-z]+"
          }, {
            className: "type",
            begin: "\\{",
            end: "\\}",
            excludeEnd: !0,
            excludeBegin: !0,
            relevance: 0
          }, {
            className: "variable",
            begin: m + "(?=\\s*(-)|$)",
            endsParent: !0,
            relevance: 0
          }, { begin: /(?=[^\n])\s/, relevance: 0 }]
        }]
      }), r.C_BLOCK_COMMENT_MODE, r.C_LINE_COMMENT_MODE]
    }, v = [r.APOS_STRING_MODE, r.QUOTE_STRING_MODE, ne, K, c, { match: /\$\d+/ }, B];
    Q.contains = v.concat({
      begin: /\{/,
      end: /\}/,
      keywords: V,
      contains: ["self"].concat(v)
    });
    const I = [].concat(f, Q.contains), F = I.concat([{
      begin: /\(/,
      end: /\)/,
      keywords: V,
      contains: ["self"].concat(I)
    }]), E = {
      className: "params",
      begin: /\(/,
      end: /\)/,
      excludeBegin: !0,
      excludeEnd: !0,
      keywords: V,
      contains: F
    }, N = { variants: [{
      match: [/class/, /\s+/, m, /\s+/, /extends/, /\s+/, y.concat(m, "(", y.concat(/\./, m), ")*")],
      scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" }
    }, {
      match: [/class/, /\s+/, m],
      scope: { 1: "keyword", 3: "title.class" }
    }] }, M = {
      relevance: 0,
      match: y.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),
      className: "title.class",
      keywords: { _: [...o, ...s] }
    }, _ = {
      variants: [{
        match: [/function/, /\s+/, m, /(?=\s*\()/]
      }, { match: [/function/, /\s*(?=\()/] }],
      className: { 1: "keyword", 3: "title.function" },
      label: "func.def",
      contains: [E],
      illegal: /%/
    }, R = {
      match: y.concat(/\b/, (ae = [...n, "super", "import"], y.concat("(?!", ae.join("|"), ")")), m, y.lookahead(/\(/)),
      className: "title.function",
      relevance: 0
    };
    var ae;
    const fe = {
      begin: y.concat(/\./, y.lookahead(y.concat(m, /(?![0-9A-Za-z$_(])/))),
      end: m,
      excludeBegin: !0,
      keywords: "prototype",
      className: "property",
      relevance: 0
    }, $ = {
      match: [/get|set/, /\s+/, m, /(?=\()/],
      className: { 1: "keyword", 3: "title.function" },
      contains: [{ begin: /\(\)/ }, E]
    }, ie = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + r.UNDERSCORE_IDENT_RE + ")\\s*=>", z = {
      match: [/const|var|let/, /\s+/, m, /\s*/, /=\s*/, /(async\s*)?/, y.lookahead(ie)],
      keywords: "async",
      className: { 1: "keyword", 3: "title.function" },
      contains: [E]
    };
    return {
      name: "Javascript",
      aliases: ["js", "jsx", "mjs", "cjs"],
      keywords: V,
      exports: {
        PARAMS_CONTAINS: F,
        CLASS_REFERENCE: M
      },
      illegal: /#(?![$_A-z])/,
      contains: [r.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }), {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      }, r.APOS_STRING_MODE, r.QUOTE_STRING_MODE, ne, K, c, f, { match: /\$\d+/ }, B, M, {
        className: "attr",
        begin: m + y.lookahead(":"),
        relevance: 0
      }, z, {
        begin: "(" + r.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [f, r.REGEXP_MODE, {
          className: "function",
          begin: ie,
          returnBegin: !0,
          end: "\\s*=>",
          contains: [{
            className: "params",
            variants: [{ begin: r.UNDERSCORE_IDENT_RE, relevance: 0 }, {
              className: null,
              begin: /\(\s*\)/,
              skip: !0
            }, {
              begin: /\(/,
              end: /\)/,
              excludeBegin: !0,
              excludeEnd: !0,
              keywords: V,
              contains: F
            }]
          }]
        }, { begin: /,/, relevance: 0 }, {
          match: /\s+/,
          relevance: 0
        }, { variants: [{ begin: "<>", end: "</>" }, {
          match: /<[A-Za-z0-9\\._:-]+\s*\/>/
        }, {
          begin: L.begin,
          "on:begin": L.isTrulyOpeningTag,
          end: L.end
        }], subLanguage: "xml", contains: [{
          begin: L.begin,
          end: L.end,
          skip: !0,
          contains: ["self"]
        }] }]
      }, _, {
        beginKeywords: "while if switch catch for"
      }, {
        begin: "\\b(?!function)" + r.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        returnBegin: !0,
        label: "func.def",
        contains: [E, r.inherit(r.TITLE_MODE, {
          begin: m,
          className: "title.function"
        })]
      }, { match: /\.\.\./, relevance: 0 }, fe, {
        match: "\\$" + m,
        relevance: 0
      }, {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [E]
      }, R, {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      }, N, $, { match: /\$[(.]/ }]
    };
  };
})();
Fe.registerLanguage("javascript", Rt);
let Se = {};
const Pt = {
  name: "NodeComplex",
  inheritAttrs: !1,
  emits: ["show", "open", "toggle", "focus", "openParent", "forget"],
  props: {
    // ref
    root: void 0,
    rootId: [String, Number],
    // options
    modelValue: void 0,
    name: [String, Number],
    openLevel: [Number, Array],
    openSpecific: Array,
    startClosed: Boolean,
    longText: Number,
    escapeQuotes: Boolean,
    deep: Boolean,
    watch: Boolean,
    preview: [Boolean, Number],
    previewInitial: Boolean,
    focus: [String, Number],
    arrow: Boolean,
    arrowOpen: String,
    arrowClosed: String,
    delimiter: String,
    more: String,
    save: Boolean,
    saveFocus: Boolean,
    // helpers
    shared: Object,
    type: String,
    parentType: String,
    parentOpen: Boolean,
    pointer: { type: [String, Number], default: "" },
    level: { type: Number, default: 0 },
    size: Number,
    position: Number,
    // functions
    escapeQuotesFn: Function,
    isPrimitiveFn: Function,
    getTypeFn: Function,
    unwrapSpecificFn: Function,
    emitFn: Function
  },
  data() {
    return {
      id: this.getId(),
      hideTimes: 0,
      isOpen: !1,
      expanded: !1,
      openSublevel: !1,
      items: [],
      getMapSet: {},
      getSize: 0,
      useOpenLevel: this.openLevel,
      useOpenSpecific: this.openSpecific,
      originalOpenLevel: this.openLevel,
      askForget: !1,
      cleared: !1,
      hover: !1,
      unwatch: () => {
      },
      initializedClosed: !1
    };
  },
  mounted() {
    this.showEmit();
  },
  created() {
    this.expanded = this.allowPreview, this.items = this.makeItems(), this.watch && (this.unwatch = this.watchModelValue(this.deep)), this.useOpenSpecific = this.openSpecific;
  },
  methods: {
    showEmit() {
      return this.emit("show", {
        pointer: this.pointer,
        focusElement: this.$refs.focusElement,
        type: "complex"
      }), !0;
    },
    getAllPointer(e) {
      let t = "*";
      if (e = String(e), e in Se)
        t = Se[e];
      else {
        const i = e.split(this.delimiter);
        i.pop(), i.length && (t = i.join(this.delimiter) + this.delimiter + "*"), Se[e] = t;
      }
      return t;
    },
    forget() {
      this.emitFn(this, "forget", { askForget: this.askForget }), this.askForget = !1, this.cleared = !0, setTimeout(() => this.cleared = !1, 1e3);
    },
    openParent() {
      this.isOpen || this.toggleOpen(null, !0);
    },
    getId() {
      return this.level === 0 ? `_${this.rootId}` : `_${this.rootId}${this.delimiter}${this.pointer}`;
    },
    watchModelValue(e) {
      return this.$watch(
        "modelValue",
        () => {
          this.items = this.makeItems();
        },
        { deep: e }
      );
    },
    getPointer(e) {
      return this.pointer ? this.pointer + this.delimiter + e : String(e);
    },
    getSpecialType(e) {
      return this.isMapSet ? this.getTypeFn(this.getMapSet[e]) : this.getTypeFn(this.modelValue[e]);
    },
    getModelValue(e) {
      return this.isMapSet ? this.getMapSet[e] : this.modelValue[e];
    },
    // prevent select on double click
    preventSelect(e) {
      e.detail > 1 && e.preventDefault();
    },
    /**
     * Get the name of key of an object or array
     * If it is an array, those keys are not named
     * @param key
     * @returns {string|*}
     */
    getName(e) {
      return this.isArray ? "" : e;
    },
    expand() {
      this.isOpen || this.toggleOpen(null, !0), this.expanded = !0, this.openSublevel = !0;
    },
    toggleOpen(e, t) {
      const i = t === void 0 ? !this.isOpen : t;
      this.setOpen(i, { user: !0 }), this.emit("toggle", {
        event: e,
        isOpen: this.isOpen,
        level: this.level,
        pointer: this.pointer
      });
    },
    emit(e, ...t) {
      this.emitFn(this, e, ...t);
    },
    makeItems() {
      switch (!0) {
        case this.isObject:
          let e = [], t = 0;
          switch (!0) {
            case this.isSet:
              this.getMapSet = Array.from(this.modelValue), e = [...Array(this.getMapSet.length).keys()], this.getSize = this.getMapSet.length;
              break;
            case this.isMap:
              this.modelValue.forEach((i, o) => {
                this.getMapSet[o] = i, e[t] = o, t++;
              }), this.getSize = t;
              break;
            default:
              for (let i in this.modelValue)
                e[t] = i, t++;
              this.getSize = t;
          }
          return e;
        case this.isArray:
          return this.getSize = this.modelValue.length, [...Array(this.modelValue.length).keys()];
        default:
          return this.modelValue;
      }
    },
    parentIsOpen() {
      return this.$parent.$options.name === "NodeComplex" && this.$parent.isOpen || this.$parent.$options.name === "VueDd";
    },
    focusEmit() {
      this.emit("focus", {
        pointer: this.pointer,
        focusElement: this.$refs.focusElement
      });
    },
    setOpen(e, { user: t }) {
      this.isOpen = e, this.emit("open", {
        isOpen: this.isOpen,
        level: this.level,
        pointer: this.pointer,
        user: t
      }), this.expanded = this.allowPreview, this.isOpen && this.$emit("openParent");
    },
    openPointer(e) {
      e ? (Ne(() => this.setOpen(!0, { user: !1 })), this.openSublevel = !1) : this.closePointer();
    },
    closePointer() {
      const e = this.parentIsOpen() || this.openLevel === 0;
      this.setOpen(this.openSublevel && e, { user: !1 }), this.openSublevel = !1;
    },
    open() {
      this.toggleOpen(null, !0);
    },
    close() {
      this.toggleOpen(null, !1);
    },
    toggle() {
      this.toggleOpen(null, !this.isOpen);
    }
  },
  computed: {
    parentIsArray() {
      return this.parentType === "array";
    },
    unwrapSpecific() {
      return this.unwrapSpecificFn(this.openSpecific);
    },
    allowPreview() {
      return !this.previewInitial && this.level === 0 ? !1 : this.preview;
    },
    isMap() {
      return this.isObject && this.modelValue instanceof Map;
    },
    isSet() {
      return this.isObject && this.modelValue instanceof Set;
    },
    isMapSet() {
      return this.isMap || this.isSet;
    },
    instanceOf() {
      const e = this.isObject && "constructor" in this.modelValue && "name" in this.modelValue.constructor ? this.modelValue.constructor.name : "";
      return e === "Object" ? "" : e;
    },
    nextLevel() {
      return this.level + 1;
    },
    charClass() {
      return this.isObject ? "vue-dd-obj-char" : "vue-dd-arr-char";
    },
    charOpen() {
      return this.isObject ? "{" : "[";
    },
    charClose() {
      return this.isObject ? "}" : "]";
    },
    functionInlinePreview() {
      const e = this.items.toString().length, t = 100;
      return e > t ? this.items.toString().substring(0, t) + "...}" : this.items.toString();
    },
    functionInline() {
      let e = this.modelValue.toString();
      switch (!0) {
        case e.startsWith("function "):
          e = e.substring(9).trim(), e.startsWith(this.name) && (e = e.substring(this.name.length));
          break;
        case e.startsWith("()"):
          e = "(){...}";
          break;
        case e.startsWith(this.name):
          e = e.substring(this.name.length);
          break;
      }
      const t = 25;
      return e.length > t && (e = e.substring(0, t) + "..."), e;
    },
    functionName() {
      let e = String(this.items);
      const t = e.indexOf(`
`);
      return t >= 0 && (e = e.substring(0, t)), Fe.highlight(e, { language: "javascript" }).value;
    },
    functionContent() {
      let e = String(this.items).trim().split(`
`);
      if (e.length) {
        const t = e.length - 1, i = e[t].indexOf("}");
        e = e.map((n) => n.substring(i)), e.shift();
        const o = e.join(`
`);
        return Fe.highlight(o, { language: "javascript" }).value;
      }
      return "";
    },
    shouldComma() {
      return this.size && this.position && this.position !== this.size;
    },
    longTextInline() {
      let e = this.modelValue.toString().substring(0, this.longText);
      return e = this.escapeQuotesFn(e), e = `"${e}..."`, e;
    },
    longTextContent() {
      let e = this.modelValue;
      return e = this.escapeQuotesFn(e), e = `"${e}"`, e;
    },
    isLongText() {
      return this.type === "longtext";
    },
    isRefReactive() {
      return this.isRef || this.isReactive;
    },
    isIterable() {
      return this.isArray || this.isObject;
    },
    isArray() {
      return this.type === "array";
    },
    isObject() {
      return this.type === "object";
    },
    isFunction() {
      return this.type === "function";
    },
    isPromise() {
      return ut(this.modelValue);
    },
    isReactive() {
      return We(this.modelValue);
    },
    isRef() {
      return Ve(this.modelValue);
    },
    isFocused() {
      return String(this.pointer) === String(this.focus);
    },
    showName() {
      return !this.parentIsArray && this.nameString || this.parentIsArray && this.parentOpen;
    },
    nameString() {
      return String(this.name);
    }
  },
  watch: {
    parentOpen(e) {
      e || (this.expanded = !1, this.setOpen(!1, { user: !1 }));
    },
    // make reactive to startClose prop change
    startClosed() {
      this.level === 0 && (console.log("start closed changed to", !this.startClosed), this.setOpen(!this.startClosed, { user: !1 }));
    },
    // opens levels
    openLevel: {
      handler(e) {
        if (this.useOpenLevel = this.openLevel, this.startClosed && this.level === 0 && !this.initializedClosed) {
          this.initializedClosed = !0;
          return;
        }
        if (typeof this.openLevel == "number" && this.openPointer(this.level < this.openLevel), this.getTypeFn(this.openLevel) === "array")
          for (let t = 0; t < this.openLevel.length; t++)
            this.openPointer(this.level === parseInt(this.openLevel[t]));
      },
      immediate: !0
    },
    // opens specific pointers
    unwrapSpecific: {
      handler(e) {
        if (this.openSpecific.length && typeof this.pointer < "u" && this.pointer !== null) {
          let t = this.getAllPointer(this.pointer);
          if (this.pointer in e || t in e) {
            if (this.pointer in this.shared.hiddenPointers)
              return;
            Ne(() => {
              this.$nextTick(() => {
                this.parentIsOpen() && this.setOpen(!0, { user: !1 });
              });
            });
          }
        }
      },
      immediate: !0
    },
    // fires events on open and closing
    isOpen: {
      handler(e, t) {
        if (e)
          this.items = this.makeItems(), this.useOpenLevel = this.openLevel, this.useOpenSpecific = this.openSpecific;
        else {
          const i = () => {
            this.useOpenLevel = 0, this.useOpenSpecific = [];
          };
          this.hideTimes === 0 ? i() : setTimeout(() => i(), 1), this.hideTimes++;
        }
      },
      immediate: !0
    },
    // expand previews
    preview(e) {
      this.expanded = e, this.setOpen(!!(this.isOpen && e), { user: !1 });
    },
    previewInitial() {
      this.expanded = this.allowPreview;
    },
    openSpecific() {
      this.useOpenSpecific = this.openSpecific;
    }
  },
  // expose: ['$options', 'open', 'toggle', 'close', 'isOpen'],
  components: {
    NodePrimitive: ze
  }
}, jt = ["id"], Bt = { class: "vue-dd-start" }, Vt = ["innerHTML"], zt = {
  key: 3,
  class: "vue-dd-colon"
}, Ht = ["innerHTML"], Dt = {
  key: 0,
  class: "vue-dd-comma"
}, Qt = ["innerHTML"], Ut = {
  key: 9,
  class: "vue-dd-instance"
}, Zt = /* @__PURE__ */ C("span", { class: "vue-dd-size-bracket" }, "[", -1), Wt = /* @__PURE__ */ C("span", { class: "vue-dd-size-bracket" }, "]", -1), Kt = { key: 0 }, Gt = { key: 1 }, Xt = { key: 13 }, qt = {
  key: 14,
  class: "vue-dd-forget-cleared"
}, Jt = ["innerHTML"], Yt = {
  key: 1,
  class: "vue-dd-promise-content"
}, $t = /* @__PURE__ */ C("span", { class: "vue-dd-size-bracket" }, "(", -1), en = ["innerHTML"], tn = /* @__PURE__ */ C("span", { class: "vue-dd-size-bracket" }, ")", -1), nn = { key: 3 }, sn = {
  key: 4,
  class: "vue-dd-f-content"
}, rn = { key: 0 }, on = ["innerHTML"], an = {
  key: 0,
  class: "vue-dd-comma"
}, ln = { key: 1 }, cn = ["innerHTML"], un = {
  key: 0,
  class: "vue-dd-comma"
}, dn = {
  key: 5,
  class: "vue-dd-string"
}, hn = { key: 0 }, gn = {
  key: 0,
  class: "vue-dd-comma"
}, pn = { key: 1 }, fn = {
  key: 0,
  class: "vue-dd-comma"
}, mn = ["innerHTML"], vn = ["innerHTML"], yn = {
  key: 8,
  class: "vue-dd-comma"
};
function bn(e, t, i, o, s, n) {
  const l = de("node-primitive"), a = de("node-complex", !0);
  return d(), h("div", {
    id: s.id,
    class: P({ "vue-dd-body": !0, "vue-dd-box-closed": !s.isOpen })
  }, [
    C("div", Bt, [
      i.saveFocus ? (d(), h("span", {
        key: 0,
        ref: "focusElement",
        class: P(["vue-dd-focus vue-dd-icon-eye", {
          "vue-dd-focus-hover": s.hover,
          "vue-dd-focus-selected": n.isFocused
        }]),
        onClick: t[0] || (t[0] = A((...r) => n.focusEmit && n.focusEmit(...r), ["prevent"])),
        onMouseenter: t[1] || (t[1] = (r) => s.hover = !0),
        onMouseup: t[2] || (t[2] = (r) => s.hover = !1),
        onMouseleave: t[3] || (t[3] = (r) => s.hover = !1)
      }, null, 34)) : b("", !0),
      i.arrow ? (d(), h("span", {
        key: 1,
        onClick: t[4] || (t[4] = A((...r) => n.toggleOpen && n.toggleOpen(...r), ["prevent"])),
        class: P(["vue-dd-arrow", { "vue-dd-arrow-collapsed": !s.isOpen }]),
        innerHTML: s.isOpen ? i.arrowOpen : i.arrowClosed
      }, null, 10, Vt)) : b("", !0),
      n.showName ? (d(), h("span", {
        key: 2,
        onClick: t[5] || (t[5] = A((...r) => n.toggleOpen && n.toggleOpen(...r), ["prevent"])),
        onMousedown: t[6] || (t[6] = (r) => n.preventSelect(r)),
        class: P(["vue-dd-name", {
          "vue-dd-f-name": n.isFunction,
          "vue-dd-key-of-array": n.parentIsArray
        }])
      }, j(i.name), 35)) : b("", !0),
      i.level !== 0 ? (d(), h("span", zt, ":")) : b("", !0),
      n.isIterable && n.isReactive ? (d(), h("span", {
        key: 4,
        onClick: t[7] || (t[7] = A((...r) => n.toggleOpen && n.toggleOpen(...r), ["prevent"])),
        onMousedown: t[8] || (t[8] = (r) => n.preventSelect(r)),
        class: "vue-dd-r",
        title: "Reactive"
      }, "R", 32)) : n.isIterable && n.isRef ? (d(), h("span", {
        key: 5,
        onClick: t[9] || (t[9] = A((...r) => n.toggleOpen && n.toggleOpen(...r), ["prevent"])),
        onMousedown: t[10] || (t[10] = (r) => n.preventSelect(r)),
        class: "vue-dd-ref",
        title: "Ref"
      }, "Ref", 32)) : n.isFunction ? (d(), h("span", {
        key: 6,
        onClick: t[11] || (t[11] = A((...r) => n.toggleOpen && n.toggleOpen(...r), ["prevent"])),
        onMousedown: t[12] || (t[12] = (r) => n.preventSelect(r)),
        class: "vue-dd-f",
        title: "Function"
      }, "f", 32)) : b("", !0),
      n.isFunction && s.isOpen ? (d(), h("pre", {
        key: 7,
        onClick: t[13] || (t[13] = A((...r) => n.toggleOpen && n.toggleOpen(...r), ["prevent"])),
        class: "vue-dd-f-start"
      }, [
        C("span", { innerHTML: n.functionName }, null, 8, Ht),
        n.shouldComma && !s.isOpen ? (d(), h("span", Dt, ",")) : b("", !0)
      ])) : b("", !0),
      n.isIterable && s.isOpen ? (d(), h("span", {
        key: 8,
        onClick: t[14] || (t[14] = A((...r) => n.toggleOpen && n.toggleOpen(...r), ["prevent"])),
        onMousedown: t[15] || (t[15] = (r) => n.preventSelect(r)),
        class: P(n.charClass),
        innerHTML: n.charOpen
      }, null, 42, Qt)) : b("", !0),
      n.isIterable && s.isOpen && n.instanceOf ? (d(), h("span", Ut, j(n.instanceOf), 1)) : b("", !0),
      n.isIterable && s.isOpen && s.getSize ? (d(), h("span", {
        key: 10,
        onClick: t[16] || (t[16] = A((...r) => n.toggleOpen && n.toggleOpen(...r), ["prevent"])),
        onMousedown: t[17] || (t[17] = (r) => n.preventSelect(r)),
        class: "vue-dd-size"
      }, [
        Zt,
        ye(j(s.getSize), 1),
        Wt
      ], 32)) : b("", !0),
      n.isIterable && n.isPromise && !s.isOpen ? (d(), h("span", {
        key: 11,
        onClick: t[18] || (t[18] = A((...r) => n.toggleOpen && n.toggleOpen(...r), ["prevent"])),
        onMousedown: t[19] || (t[19] = (r) => n.preventSelect(r)),
        class: "vue-dd-instance vue-dd-promise-prototype"
      }, "Promise", 32)) : b("", !0),
      s.isOpen && i.level === 0 && i.save && !s.cleared ? (d(), h("span", {
        key: 12,
        onClick: t[20] || (t[20] = A((r) => s.askForget = !0, ["prevent"])),
        class: P(["vue-dd-forget vue-dd-forget-q", { "vue-dd-forget-q-ask": s.askForget }])
      }, [
        s.askForget ? (d(), h("span", Kt, "clear save?")) : (d(), h("span", Gt, "forget"))
      ], 2)) : b("", !0),
      s.askForget ? (d(), h("span", Xt, [
        C("span", {
          class: "vue-dd-forget vue-dd-forget-yes",
          onClick: t[21] || (t[21] = A((...r) => n.forget && n.forget(...r), ["prevent"]))
        }, "yes"),
        C("span", {
          class: "vue-dd-forget vue-dd-forget-no",
          onClick: t[22] || (t[22] = A((r) => s.askForget = !1, ["prevent"]))
        }, "no")
      ])) : b("", !0),
      s.cleared ? (d(), h("span", qt, " cleared ")) : b("", !0)
    ]),
    C("div", {
      class: P({
        "vue-dd-box": s.isOpen,
        "vue-dd-box-closed": !s.isOpen,
        "vue-dd-box-complex": !0
      })
    }, [
      C("div", null, [
        n.isIterable && !s.isOpen ? (d(), h("span", {
          key: 0,
          class: P(n.charClass),
          innerHTML: n.charOpen
        }, null, 10, Jt)) : b("", !0),
        n.isIterable && n.isPromise ? (d(), h("span", Yt, "<pending>")) : b("", !0),
        n.isIterable && !s.isOpen && !n.allowPreview ? (d(), h("span", {
          key: 2,
          onClick: t[23] || (t[23] = A((...r) => n.expand && n.expand(...r), ["prevent"])),
          class: "vue-dd-expand"
        }, [
          $t,
          C("span", {
            class: "vue-dd-expand-more",
            innerHTML: i.more
          }, null, 8, en),
          tn
        ])) : b("", !0),
        n.isIterable && (s.isOpen || s.expanded) ? (d(), h("div", nn, [
          (d(!0), h(Ke, null, Ge(s.isOpen ? s.items.length : n.allowPreview < s.items.length ? n.allowPreview : s.items.length, (r) => (d(), h("div", { key: r }, [
            C("div", null, [
              i.isPrimitiveFn(n.getSpecialType(s.items[r - 1])) ? (d(), he(l, {
                key: 0,
                root: i.root,
                rootId: i.rootId,
                modelValue: n.getModelValue(s.items[r - 1]),
                name: s.items[r - 1],
                escapeQuotes: i.escapeQuotes,
                focus: i.focus,
                save: i.save,
                saveFocus: i.saveFocus,
                delimiter: i.delimiter,
                pointer: n.getPointer(s.items[r - 1]),
                parentOpen: s.isOpen,
                type: n.getSpecialType(s.items[r - 1]),
                parentType: i.type,
                size: s.getSize,
                position: r,
                expanded: s.expanded,
                escapeQuotesFn: i.escapeQuotesFn,
                emitFn: i.emitFn,
                onOpenParent: n.openParent
              }, null, 8, ["root", "rootId", "modelValue", "name", "escapeQuotes", "focus", "save", "saveFocus", "delimiter", "pointer", "parentOpen", "type", "parentType", "size", "position", "expanded", "escapeQuotesFn", "emitFn", "onOpenParent"])) : (d(), he(a, {
                key: 1,
                root: i.root,
                rootId: i.rootId,
                modelValue: n.getModelValue(s.items[r - 1]),
                name: s.items[r - 1],
                deep: n.isRef ? !1 : i.deep,
                watch: i.watch,
                preview: s.isOpen ? i.preview : !1,
                openLevel: s.useOpenLevel,
                openSpecific: s.useOpenSpecific,
                startClosed: i.startClosed,
                longText: i.longText,
                escapeQuotes: i.escapeQuotes,
                focus: i.focus,
                save: i.save,
                saveFocus: i.saveFocus,
                delimiter: i.delimiter,
                more: i.more,
                arrow: i.arrow,
                arrowOpen: i.arrowOpen,
                arrowClosed: i.arrowClosed,
                pointer: n.getPointer(s.items[r - 1]),
                parentType: i.type,
                parentOpen: s.isOpen,
                type: n.getSpecialType(s.items[r - 1]),
                shared: i.shared,
                level: i.level + 1,
                size: s.getSize,
                position: r,
                escapeQuotesFn: i.escapeQuotesFn,
                getTypeFn: i.getTypeFn,
                isPrimitiveFn: i.isPrimitiveFn,
                unwrapSpecificFn: i.unwrapSpecificFn,
                emitFn: i.emitFn,
                onOpenParent: n.openParent
              }, null, 8, ["root", "rootId", "modelValue", "name", "deep", "watch", "preview", "openLevel", "openSpecific", "startClosed", "longText", "escapeQuotes", "focus", "save", "saveFocus", "delimiter", "more", "arrow", "arrowOpen", "arrowClosed", "pointer", "parentType", "parentOpen", "type", "shared", "level", "size", "position", "escapeQuotesFn", "getTypeFn", "isPrimitiveFn", "unwrapSpecificFn", "emitFn", "onOpenParent"]))
            ])
          ]))), 128))
        ])) : b("", !0),
        n.isFunction ? (d(), h("div", sn, [
          s.isOpen && n.functionContent ? (d(), h("pre", rn, [
            C("span", { innerHTML: n.functionContent }, null, 8, on),
            n.shouldComma ? (d(), h("span", an, ",")) : b("", !0)
          ])) : s.isOpen && !n.functionContent ? (d(), h("span", ln)) : (d(), h("span", {
            key: 2,
            onClick: t[24] || (t[24] = A((...r) => n.toggleOpen && n.toggleOpen(...r), ["prevent"])),
            class: "vue-dd-f-inline"
          }, [
            C("span", {
              innerHTML: n.allowPreview ? n.functionInlinePreview : n.functionInline
            }, null, 8, cn),
            n.shouldComma ? (d(), h("span", un, ",")) : b("", !0)
          ]))
        ])) : b("", !0),
        n.isLongText ? (d(), h("div", dn, [
          s.isOpen ? (d(), h("span", hn, [
            ye(j(n.longTextContent), 1),
            n.shouldComma ? (d(), h("span", gn, ",")) : b("", !0)
          ])) : (d(), h("span", pn, [
            ye(j(n.longTextInline), 1),
            n.shouldComma ? (d(), h("span", fn, ",")) : b("", !0)
          ]))
        ])) : b("", !0),
        n.isIterable && !s.isOpen && n.allowPreview && i.preview < s.items.length ? (d(), h("span", {
          key: 6,
          onClick: t[25] || (t[25] = A((...r) => n.expand && n.expand(...r), ["prevent"])),
          class: "vue-dd-expand",
          innerHTML: i.more
        }, null, 8, mn)) : b("", !0),
        n.isIterable ? (d(), h("span", {
          key: 7,
          class: P(n.charClass),
          innerHTML: n.charClose
        }, null, 10, vn)) : b("", !0),
        n.isIterable && n.shouldComma ? (d(), h("span", yn, ",")) : b("", !0)
      ])
    ], 2)
  ], 10, jt);
}
const Sn = /* @__PURE__ */ ge(Pt, [["render", bn]]);
let we = {};
const wn = Xe({
  name: "VueDd",
  inheritAttrs: !1,
  emits: ["open", "toggle", "focus", "show"],
  props: {
    // main options
    modelValue: { type: void 0, required: !0 },
    id: { type: [String, Number], default: "" },
    name: { type: String, default: "" },
    openLevel: { type: [Number, String, Array], default: 0 },
    openSpecific: { type: Array, default: () => [] },
    startClosed: { type: Boolean, default: !1 },
    focus: { type: [String, Number], default: null },
    focusSticky: { type: Boolean, default: !1 },
    focusOffsetX: { type: Number, default: -35 },
    focusOffsetY: { type: Number, default: -15 },
    focusDelay: { type: Number, default: 150 },
    preview: { type: [Number, Boolean], default: 5 },
    previewInitial: { type: Boolean, default: !0 },
    escapeQuotes: { type: Boolean, default: !1 },
    longText: { type: Number, default: 50 },
    delimiter: { type: String, default: "." },
    more: { type: String, default: "..." },
    // styling options
    arrow: { type: Boolean, default: !0 },
    arrowOpen: { type: String, default: "&#x25BC;" },
    arrowClosed: { type: String, default: "&#x25BC;" },
    inline: { type: Boolean, default: !0 },
    dark: { type: Boolean, default: !0 },
    fontFamily: { type: String, default: '"JetBrains Mono", "Courier", serif' },
    fontSize: { type: String, default: ".7rem" },
    lineHeight: { type: String, default: "1rem" },
    paddingLeft: { type: String, default: ".7rem" },
    maxHeight: { type: String, default: "500px" },
    maxWidth: { type: String, default: "100%" },
    // save
    save: { type: Boolean, default: !1 },
    saveFocus: { type: Boolean, default: !0 },
    storage: { type: String, default: "local" },
    // session | local
    // watch options
    watch: { type: Boolean, default: !0 },
    deep: { type: Boolean, default: !0 }
  },
  data() {
    return {
      rootId: dt(this.id, this.name, window),
      openClass: !1,
      css: this.class,
      useOpenSpecific: this.openSpecific,
      // if openLevel is string, convert to number int
      memory: null,
      shared: {
        hiddenPointers: {}
        // must be defined as empty
      },
      setFocusAlready: !1,
      useFocus: null,
      // saveFocus only works, if you supply an id or a name for the object
      useSaveFocus: !this.id && !this.name ? !1 : this.saveFocus
    };
  },
  created() {
    (this.save || this.useSaveFocus) && this.initMemory(), this.useFocus = this.getFocus(), this.useOpenSpecific = this.getOpenSpecific();
  },
  mounted() {
  },
  computed: {
    useOpenLevel() {
      return typeof this.openLevel == "string" ? parseInt(this.openLevel) : this.openLevel;
    },
    cssVars() {
      return {
        "--vue-dd-fontFamily": this.fontFamily,
        "--vue-dd-fontSize": this.fontSize,
        "--vue-dd-lineHeight": this.lineHeight,
        "--vue-dd-paddingLeft": this.paddingLeft,
        "--vue-dd-maxHeight": this.maxHeight,
        "--vue-dd-maxWidth": this.maxWidth
      };
    },
    unwrapSpecific() {
      return this.unwrapSpecificFn(this.openSpecific);
    },
    type() {
      return this.getTypeFn(this.modelValue);
    },
    primitive() {
      return this.isPrimitiveFn(this.type);
    },
    isSet() {
      return this.type === "object" && this.modelValue instanceof Set;
    },
    isRef() {
      return Ve(this.modelValue);
    }
  },
  methods: {
    forgetEmit() {
      this.save && typeof this.memory == "object" && (this.memory.open = {}, this.shared.hiddenPointers = {}, this.useOpenSpecific = this.baseOpenSpecific(), this.store().set(this.memory));
    },
    setFocus() {
      if (this.useSaveFocus && this.useFocus !== null) {
        let e = !0;
        this.setFocusAlready && (e = !1), this.focusSticky && (e = !0), e && setTimeout(() => {
          const t = this.getElement(this.useFocus);
          t && (this.$refs.root.scrollLeft = t.offsetLeft + this.focusOffsetX, this.$refs.root.scrollTop = t.offsetTop + this.focusOffsetY, t.classList.add("vue-dd-highlight"), setTimeout(() => t.classList.remove("vue-dd-highlight"), 500), this.setFocusAlready = !0);
        }, this.focusDelay);
      }
    },
    getElement(e) {
      e = e === "" ? "" : `${this.delimiter}${e}`;
      const t = `_${this.rootId}${e}`;
      return document.getElementById(t);
    },
    getFocus() {
      let e = this.focus;
      return this.useSaveFocus && "focus" in this.memory && this.memory.focus !== null && (e = String(this.memory.focus)), e;
    },
    initMemory() {
      this.memory = this.store().get(), Ie(this.memory) || (this.memory = {}), (!("open" in this.memory) || !Ie(this.memory.open)) && (this.memory.open = {}), "focus" in this.memory || (this.memory.focus = null);
    },
    getOpenSpecific() {
      if (this.save) {
        this.memory.open = { ...this.memory.open, ...this.unwrapSpecific }, this.store().set(this.memory);
        let e = [];
        for (let t in this.memory.open)
          e.push(String(t));
        return e;
      } else
        return this.baseOpenSpecific();
    },
    baseOpenSpecific() {
      return [...this.openSpecific, ...this.useFocus === null ? [] : [String(this.useFocus)]];
    },
    focusEmit(e) {
      let { pointer: t, focusElement: i } = e;
      if (this.useSaveFocus) {
        const o = this.useFocus;
        if (String(t) === String(o) && String(t) !== String(this.focus)) {
          if (this.openSpecific.indexOf(t) === -1) {
            const s = this.useOpenSpecific.indexOf(t);
            s > -1 && this.useOpenSpecific.splice(s, 1);
          }
          delete this.memory.open[t], t = null, i.classList.remove("vue-dd-focus-selected");
        } else {
          if (this.openSpecific.indexOf(o) === -1) {
            const n = this.useOpenSpecific.indexOf(o);
            n > -1 && this.useOpenSpecific.splice(n, 1);
          }
          delete this.memory.open[o];
          const s = this.getElement(o);
          if (s) {
            const n = s.querySelector(".vue-dd-focus");
            n && n.classList.remove("vue-dd-focus-selected");
          }
          i.classList.add("vue-dd-focus-selected");
        }
        this.memory.focus = t === null ? this.focus : t, this.useOpenSpecific.push(this.memory.focus), this.store().set(this.memory), this.useFocus = this.memory.focus, this.emitFn(this, "focus", { focus: this.memory.focus, focusElement: i });
      }
    },
    showEmit(e) {
      let { type: t, pointer: i, focusElement: o } = e;
      this.emitFn(this, "show", e), this.useSaveFocus && this.useFocus === i && this.setFocus();
    },
    openEmit(e) {
      const { isOpen: t, pointer: i, level: o, user: s } = e;
      o === 0 && (this.startClosed && t && this.useOpenSpecific.indexOf("") === -1 && this.useOpenSpecific.push(""), this.openClass = t), this.$emit("open", e);
    },
    toggleEmit(e) {
      const { event: t, isOpen: i, pointer: o, level: s } = e;
      if (this.save) {
        const n = o in this.unwrapSpecific;
        if (i)
          delete this.shared.hiddenPointers[o], n || this.useOpenSpecific.push(o), this.memory.open[o] = !0;
        else {
          if (this.shared.hiddenPointers[o] = !0, n) {
            const l = this.useOpenSpecific.indexOf(o);
            l >= 0 && delete this.useOpenSpecific[l];
          }
          delete this.memory.open[o];
        }
        this.store().set(this.memory);
      }
      this.$emit("toggle", e);
    },
    store() {
      const e = "vue-dd." + this.rootId;
      return {
        get: () => {
          try {
            return JSON.parse(window[`${this.storage}Storage`].getItem(e));
          } catch {
          }
        },
        set: (t) => window[`${this.storage}Storage`].setItem(e, JSON.stringify(t))
      };
    },
    getTypeFn(e) {
      let t = typeof e;
      return t === "object" ? e === null ? "null" : Array.isArray(e) ? "array" : "object" : (t === "string" && e.length > this.longText && (t = "longtext"), t);
    },
    isPrimitiveFn(e) {
      return !(e === "array" || e === "object" || e === "function" || e === "longtext");
    },
    escapeQuotesFn(e) {
      return this.escapeQuotes ? e.replaceAll('"', '\\"') : e;
    },
    unwrapSpecificFn(e) {
      let t = {};
      if (e.length) {
        const i = e;
        if (i in we)
          return we[i];
        e.forEach((o) => {
          const s = String(o).split(this.delimiter);
          let n = "", l = 0;
          for (let a in s)
            n += (l > 0 ? this.delimiter : "") + s[a], t[n] = !0, l++;
          l > 0 && (t[""] = !0);
        }), this.useFocus !== null && (t[this.useFocus] = !0), this.startClosed && "" in t && delete t[""], we[i] = t;
      }
      return t;
    },
    // recursive emit
    // more info: https://stackoverflow.com/a/55650245/1502706
    emitFn(e, t, ...i) {
      for (; e && !(e.$options.name !== "VueDd" && e.$options.name !== "NodeComplex" && e.$options.name !== "NodePrimitive"); )
        e.$emit(t, ...i), e = e.$parent;
    },
    open() {
      this.$refs.nodeComplex.open();
    },
    close() {
      this.$refs.nodeComplex.close();
    },
    toggle() {
      this.$refs.nodeComplex.toggle();
    }
    // isOpen() {
    //   return this.$refs.nodeComplex.isOpen
    // }
  },
  watch: {
    modelValue: {
      handler(e, t) {
        this.focusSticky && e !== t && this.setFocus();
      }
    },
    openSpecific() {
      this.useOpenSpecific = this.getOpenSpecific();
    },
    save() {
      this.useOpenSpecific = this.getOpenSpecific();
    }
  },
  // expose: ['$options', 'open', 'toggle', 'close', 'isOpen', 'root'],
  components: {
    NodeComplex: Sn,
    NodePrimitive: ze
  }
});
const On = ["id"];
function En(e, t, i, o, s, n) {
  const l = de("node-primitive"), a = de("node-complex");
  return d(), h("div", {
    ref: "root",
    id: e.rootId,
    class: P(["vue-dd", {
      "vue-dd-inline": e.inline,
      "vue-dd-open": e.openClass,
      "vue-dd-dark": e.dark,
      "vue-dd-no-arrow": !e.arrow
    }, e.$attrs.class]),
    style: qe([e.cssVars, e.$attrs.style])
  }, [
    e.primitive ? (d(), he(l, {
      key: 0,
      root: e.$refs.root,
      rootId: e.rootId,
      modelValue: e.modelValue,
      name: e.name,
      focus: e.useFocus,
      escapeQuotes: e.escapeQuotes,
      save: e.save,
      saveFocus: e.useSaveFocus,
      delimiter: e.delimiter,
      pointer: "",
      type: e.type,
      parentOpen: !1,
      parentType: "",
      escapeQuotesFn: e.escapeQuotesFn,
      emitFn: e.emitFn,
      onFocus: e.focusEmit,
      onShow: e.showEmit
    }, null, 8, ["root", "rootId", "modelValue", "name", "focus", "escapeQuotes", "save", "saveFocus", "delimiter", "type", "escapeQuotesFn", "emitFn", "onFocus", "onShow"])) : (d(), he(a, {
      key: 1,
      ref: "nodeComplex",
      root: e.$refs.root,
      rootId: e.rootId,
      modelValue: e.modelValue,
      name: e.name,
      openLevel: e.useOpenLevel,
      openSpecific: e.useOpenSpecific,
      focus: e.useFocus,
      escapeQuotes: e.escapeQuotes,
      startClosed: e.startClosed,
      longText: e.longText,
      preview: e.preview,
      previewInitial: e.previewInitial,
      deep: e.isRef ? !0 : e.deep,
      watch: e.watch,
      save: e.save,
      saveFocus: e.useSaveFocus,
      arrow: e.arrow,
      arrowOpen: e.arrowOpen,
      arrowClosed: e.arrowClosed,
      delimiter: e.delimiter,
      more: e.more,
      pointer: "",
      type: e.type,
      parentType: "",
      parentOpen: !1,
      shared: e.shared,
      getTypeFn: e.getTypeFn,
      isPrimitiveFn: e.isPrimitiveFn,
      escapeQuotesFn: e.escapeQuotesFn,
      unwrapSpecificFn: e.unwrapSpecificFn,
      emitFn: e.emitFn,
      onShow: e.showEmit,
      onToggle: e.toggleEmit,
      onOpen: e.openEmit,
      onFocus: e.focusEmit,
      onForget: e.forgetEmit
    }, null, 8, ["root", "rootId", "modelValue", "name", "openLevel", "openSpecific", "focus", "escapeQuotes", "startClosed", "longText", "preview", "previewInitial", "deep", "watch", "save", "saveFocus", "arrow", "arrowOpen", "arrowClosed", "delimiter", "more", "type", "shared", "getTypeFn", "isPrimitiveFn", "escapeQuotesFn", "unwrapSpecificFn", "emitFn", "onShow", "onToggle", "onOpen", "onFocus", "onForget"]))
  ], 14, On);
}
const kn = /* @__PURE__ */ ge(wn, [["render", En]]), Fn = {};
function _n(e, t) {
  return d(), h("div", null, "Hello world");
}
const xn = /* @__PURE__ */ ge(Fn, [["render", _n]]);
function Nn(e) {
  e.component("VueDd", kn), e.component("XRay", xn);
}
export {
  kn as VueDd,
  xn as XRay,
  Nn as install
};
